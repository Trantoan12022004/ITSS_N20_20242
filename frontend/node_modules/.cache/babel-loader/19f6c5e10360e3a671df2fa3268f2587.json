{"ast":null,"code":"// For each opening emphasis-like marker find a matching closing one\n//\nfunction processDelimiters(delimiters) {\n  const openersBottom = {};\n  const max = delimiters.length;\n  if (!max) return; // headerIdx is the first delimiter of the current (where closer is) delimiter run\n\n  let headerIdx = 0;\n  let lastTokenIdx = -2; // needs any value lower than -1\n\n  const jumps = [];\n\n  for (let closerIdx = 0; closerIdx < max; closerIdx++) {\n    const closer = delimiters[closerIdx];\n    jumps.push(0); // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n\n    lastTokenIdx = closer.token; // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n\n    closer.length = closer.length || 0;\n    if (!closer.close) continue; // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n\n    /* eslint-disable-next-line no-prototype-builtins */\n\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n    }\n\n    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n    let openerIdx = headerIdx - jumps[headerIdx] - 1;\n    let newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      const opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n        let isOddMatch = false; // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1; // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\nexport default function link_pairs(state) {\n  const tokens_meta = state.tokens_meta;\n  const max = state.tokens_meta.length;\n  processDelimiters(state.delimiters);\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(tokens_meta[curr].delimiters);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs"],"names":["processDelimiters","delimiters","openersBottom","max","length","headerIdx","lastTokenIdx","jumps","closerIdx","closer","push","marker","token","close","hasOwnProperty","minOpenerIdx","open","openerIdx","newMinOpenerIdx","opener","end","isOddMatch","lastJump","link_pairs","state","tokens_meta","curr"],"mappings":"AAAA;AACA;AAEA,SAASA,iBAAT,CAA4BC,UAA5B,EAAwC;AACtC,QAAMC,aAAa,GAAG,EAAtB;AACA,QAAMC,GAAG,GAAGF,UAAU,CAACG,MAAvB;AAEA,MAAI,CAACD,GAAL,EAAU,OAJ4B,CAMtC;;AACA,MAAIE,SAAS,GAAG,CAAhB;AACA,MAAIC,YAAY,GAAG,CAAC,CAApB,CARsC,CAQhB;;AACtB,QAAMC,KAAK,GAAG,EAAd;;AAEA,OAAK,IAAIC,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGL,GAApC,EAAyCK,SAAS,EAAlD,EAAsD;AACpD,UAAMC,MAAM,GAAGR,UAAU,CAACO,SAAD,CAAzB;AAEAD,IAAAA,KAAK,CAACG,IAAN,CAAW,CAAX,EAHoD,CAKpD;AACA;AACA;AACA;;AACA,QAAIT,UAAU,CAACI,SAAD,CAAV,CAAsBM,MAAtB,KAAiCF,MAAM,CAACE,MAAxC,IAAkDL,YAAY,KAAKG,MAAM,CAACG,KAAP,GAAe,CAAtF,EAAyF;AACvFP,MAAAA,SAAS,GAAGG,SAAZ;AACD;;AAEDF,IAAAA,YAAY,GAAGG,MAAM,CAACG,KAAtB,CAboD,CAepD;AACA;AACA;AACA;;AACAH,IAAAA,MAAM,CAACL,MAAP,GAAgBK,MAAM,CAACL,MAAP,IAAiB,CAAjC;AAEA,QAAI,CAACK,MAAM,CAACI,KAAZ,EAAmB,SArBiC,CAuBpD;AACA;AACA;AACA;;AACA;;AACA,QAAI,CAACX,aAAa,CAACY,cAAd,CAA6BL,MAAM,CAACE,MAApC,CAAL,EAAkD;AAChDT,MAAAA,aAAa,CAACO,MAAM,CAACE,MAAR,CAAb,GAA+B,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAS,CAAC,CAAV,EAAa,CAAC,CAAd,EAAiB,CAAC,CAAlB,EAAqB,CAAC,CAAtB,CAA/B;AACD;;AAED,UAAMI,YAAY,GAAGb,aAAa,CAACO,MAAM,CAACE,MAAR,CAAb,CAA6B,CAACF,MAAM,CAACO,IAAP,GAAc,CAAd,GAAkB,CAAnB,IAAyBP,MAAM,CAACL,MAAP,GAAgB,CAAtE,CAArB;AAEA,QAAIa,SAAS,GAAGZ,SAAS,GAAGE,KAAK,CAACF,SAAD,CAAjB,GAA+B,CAA/C;AAEA,QAAIa,eAAe,GAAGD,SAAtB;;AAEA,WAAOA,SAAS,GAAGF,YAAnB,EAAiCE,SAAS,IAAIV,KAAK,CAACU,SAAD,CAAL,GAAmB,CAAjE,EAAoE;AAClE,YAAME,MAAM,GAAGlB,UAAU,CAACgB,SAAD,CAAzB;AAEA,UAAIE,MAAM,CAACR,MAAP,KAAkBF,MAAM,CAACE,MAA7B,EAAqC;;AAErC,UAAIQ,MAAM,CAACH,IAAP,IAAeG,MAAM,CAACC,GAAP,GAAa,CAAhC,EAAmC;AACjC,YAAIC,UAAU,GAAG,KAAjB,CADiC,CAGjC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIF,MAAM,CAACN,KAAP,IAAgBJ,MAAM,CAACO,IAA3B,EAAiC;AAC/B,cAAI,CAACG,MAAM,CAACf,MAAP,GAAgBK,MAAM,CAACL,MAAxB,IAAkC,CAAlC,KAAwC,CAA5C,EAA+C;AAC7C,gBAAIe,MAAM,CAACf,MAAP,GAAgB,CAAhB,KAAsB,CAAtB,IAA2BK,MAAM,CAACL,MAAP,GAAgB,CAAhB,KAAsB,CAArD,EAAwD;AACtDiB,cAAAA,UAAU,GAAG,IAAb;AACD;AACF;AACF;;AAED,YAAI,CAACA,UAAL,EAAiB;AACf;AACA;AACA;AACA;AACA,gBAAMC,QAAQ,GAAGL,SAAS,GAAG,CAAZ,IAAiB,CAAChB,UAAU,CAACgB,SAAS,GAAG,CAAb,CAAV,CAA0BD,IAA5C,GACbT,KAAK,CAACU,SAAS,GAAG,CAAb,CAAL,GAAuB,CADV,GAEb,CAFJ;AAIAV,UAAAA,KAAK,CAACC,SAAD,CAAL,GAAmBA,SAAS,GAAGS,SAAZ,GAAwBK,QAA3C;AACAf,UAAAA,KAAK,CAACU,SAAD,CAAL,GAAmBK,QAAnB;AAEAb,UAAAA,MAAM,CAACO,IAAP,GAAe,KAAf;AACAG,UAAAA,MAAM,CAACC,GAAP,GAAeZ,SAAf;AACAW,UAAAA,MAAM,CAACN,KAAP,GAAe,KAAf;AACAK,UAAAA,eAAe,GAAG,CAAC,CAAnB,CAfe,CAgBf;AACA;;AACAZ,UAAAA,YAAY,GAAG,CAAC,CAAhB;AACA;AACD;AACF;AACF;;AAED,QAAIY,eAAe,KAAK,CAAC,CAAzB,EAA4B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACAhB,MAAAA,aAAa,CAACO,MAAM,CAACE,MAAR,CAAb,CAA6B,CAACF,MAAM,CAACO,IAAP,GAAc,CAAd,GAAkB,CAAnB,IAAyB,CAACP,MAAM,CAACL,MAAP,IAAiB,CAAlB,IAAuB,CAA7E,IAAmFc,eAAnF;AACD;AACF;AACF;;AAED,eAAe,SAASK,UAAT,CAAqBC,KAArB,EAA4B;AACzC,QAAMC,WAAW,GAAGD,KAAK,CAACC,WAA1B;AACA,QAAMtB,GAAG,GAAGqB,KAAK,CAACC,WAAN,CAAkBrB,MAA9B;AAEAJ,EAAAA,iBAAiB,CAACwB,KAAK,CAACvB,UAAP,CAAjB;;AAEA,OAAK,IAAIyB,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGvB,GAA1B,EAA+BuB,IAAI,EAAnC,EAAuC;AACrC,QAAID,WAAW,CAACC,IAAD,CAAX,IAAqBD,WAAW,CAACC,IAAD,CAAX,CAAkBzB,UAA3C,EAAuD;AACrDD,MAAAA,iBAAiB,CAACyB,WAAW,CAACC,IAAD,CAAX,CAAkBzB,UAAnB,CAAjB;AACD;AACF;AACF","sourcesContent":["// For each opening emphasis-like marker find a matching closing one\n//\n\nfunction processDelimiters (delimiters) {\n  const openersBottom = {}\n  const max = delimiters.length\n\n  if (!max) return\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  let headerIdx = 0\n  let lastTokenIdx = -2 // needs any value lower than -1\n  const jumps = []\n\n  for (let closerIdx = 0; closerIdx < max; closerIdx++) {\n    const closer = delimiters[closerIdx]\n\n    jumps.push(0)\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx\n    }\n\n    lastTokenIdx = closer.token\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0\n\n    if (!closer.close) continue\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1]\n    }\n\n    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)]\n\n    let openerIdx = headerIdx - jumps[headerIdx] - 1\n\n    let newMinOpenerIdx = openerIdx\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      const opener = delimiters[openerIdx]\n\n      if (opener.marker !== closer.marker) continue\n\n      if (opener.open && opener.end < 0) {\n        let isOddMatch = false\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open\n            ? jumps[openerIdx - 1] + 1\n            : 0\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump\n          jumps[openerIdx] = lastJump\n\n          closer.open  = false\n          opener.end   = closerIdx\n          opener.close = false\n          newMinOpenerIdx = -1\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2\n          break\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx\n    }\n  }\n}\n\nexport default function link_pairs (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  processDelimiters(state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(tokens_meta[curr].delimiters)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}