{"ast":null,"code":"// Parser state class\nimport Token from '../token.mjs';\nimport { isSpace } from '../common/utils.mjs';\n\nfunction StateBlock(src, md, env, tokens) {\n  this.src = src; // link to parser instance\n\n  this.md = md;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)\n\n  this.sCount = []; // indents for each line (tabs expanded)\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n\n  this.bsCount = []; // block parser variables\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n\n  this.blkIndent = 0;\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n\n  this.parentType = 'root';\n  this.level = 0; // Create caches\n  // Generate markers.\n\n  const s = this.src;\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n} // Push new token to \"stream\".\n//\n\n\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting);\n  token.block = true;\n  if (nesting < 0) this.level--; // closing tag\n\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip spaces from given position in reverse.\n\n\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return '';\n  }\n\n  const queue = new Array(end - begin);\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0;\n    const lineStart = this.bMarks[line];\n    let first = lineStart;\n    let last;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n}; // re-export Token class to use in block rules\n\n\nStateBlock.prototype.Token = Token;\nexport default StateBlock;","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/state_block.mjs"],"names":["Token","isSpace","StateBlock","src","md","env","tokens","bMarks","eMarks","tShift","sCount","bsCount","blkIndent","line","lineMax","tight","ddIndent","listIndent","parentType","level","s","start","pos","indent","offset","len","length","indent_found","ch","charCodeAt","push","prototype","type","tag","nesting","token","block","isEmpty","skipEmptyLines","from","max","skipSpaces","skipSpacesBack","min","skipChars","code","skipCharsBack","getLines","begin","end","keepLastLF","queue","Array","i","lineIndent","lineStart","first","last","join","slice"],"mappings":"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","sourcesContent":["// Parser state class\n\nimport Token from '../token.mjs'\nimport { isSpace } from '../common/utils.mjs'\n\nfunction StateBlock (src, md, env, tokens) {\n  this.src = src\n\n  // link to parser instance\n  this.md     = md\n\n  this.env = env\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens\n\n  this.bMarks = []  // line begin offsets for fast jumps\n  this.eMarks = []  // line end offsets for fast jumps\n  this.tShift = []  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = []\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent  = 0\n  this.line       = 0 // line index in src\n  this.lineMax    = 0 // lines count\n  this.tight      = false  // loose/tight mode for lists\n  this.ddIndent   = -1 // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1 // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root'\n\n  this.level = 0\n\n  // Create caches\n  // Generate markers.\n  const s = this.src\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos)\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4\n        } else {\n          offset++\n        }\n        continue\n      } else {\n        indent_found = true\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++ }\n      this.bMarks.push(start)\n      this.eMarks.push(pos)\n      this.tShift.push(indent)\n      this.sCount.push(offset)\n      this.bsCount.push(0)\n\n      indent_found = false\n      indent = 0\n      offset = 0\n      start = pos + 1\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length)\n  this.eMarks.push(s.length)\n  this.tShift.push(0)\n  this.sCount.push(0)\n  this.bsCount.push(0)\n\n  this.lineMax = this.bMarks.length - 1 // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting)\n  token.block = true\n\n  if (nesting < 0) this.level-- // closing tag\n  token.level = this.level\n  if (nesting > 0) this.level++ // opening tag\n\n  this.tokens.push(token)\n  return token\n}\n\nStateBlock.prototype.isEmpty = function isEmpty (line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]\n}\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines (from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break\n    }\n  }\n  return from\n}\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces (pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n  }\n  return pos\n}\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack (pos, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1 }\n  }\n  return pos\n}\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars (pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break }\n  }\n  return pos\n}\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack (pos, code, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1 }\n  }\n  return pos\n}\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines (begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return ''\n  }\n\n  const queue = new Array(end - begin)\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0\n    const lineStart = this.bMarks[line]\n    let first = lineStart\n    let last\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1\n    } else {\n      last = this.eMarks[line]\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first)\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4\n        } else {\n          lineIndent++\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++\n      } else {\n        break\n      }\n\n      first++\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)\n    } else {\n      queue[i] = this.src.slice(first, last)\n    }\n  }\n\n  return queue.join('')\n}\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token\n\nexport default StateBlock\n"]},"metadata":{},"sourceType":"module"}