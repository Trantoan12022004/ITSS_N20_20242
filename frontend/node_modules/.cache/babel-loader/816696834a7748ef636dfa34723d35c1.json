{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeNonAsciiHTML = exports.encodeHTML = void 0;\n\nvar encode_html_js_1 = __importDefault(require(\"./generated/encode-html.js\"));\n\nvar escape_js_1 = require(\"./escape.js\");\n\nvar htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\n\nfunction encodeHTML(data) {\n  return encodeHTMLTrieRe(htmlReplacer, data);\n}\n\nexports.encodeHTML = encodeHTML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\n\nfunction encodeNonAsciiHTML(data) {\n  return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);\n}\n\nexports.encodeNonAsciiHTML = encodeNonAsciiHTML;\n\nfunction encodeHTMLTrieRe(regExp, str) {\n  var ret = \"\";\n  var lastIdx = 0;\n  var match;\n\n  while ((match = regExp.exec(str)) !== null) {\n    var i = match.index;\n    ret += str.substring(lastIdx, i);\n    var char = str.charCodeAt(i);\n    var next = encode_html_js_1.default.get(char);\n\n    if (typeof next === \"object\") {\n      // We are in a branch. Try to match the next char.\n      if (i + 1 < str.length) {\n        var nextChar = str.charCodeAt(i + 1);\n        var value = typeof next.n === \"number\" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);\n\n        if (value !== undefined) {\n          ret += value;\n          lastIdx = regExp.lastIndex += 1;\n          continue;\n        }\n      }\n\n      next = next.v;\n    } // We might have a tree node without a value; skip and use a numeric entity.\n\n\n    if (next !== undefined) {\n      ret += next;\n      lastIdx = i + 1;\n    } else {\n      var cp = (0, escape_js_1.getCodePoint)(str, i);\n      ret += \"&#x\".concat(cp.toString(16), \";\"); // Increase by 1 if we have a surrogate pair\n\n      lastIdx = regExp.lastIndex += Number(cp !== char);\n    }\n  }\n\n  return ret + str.substr(lastIdx);\n}","map":{"version":3,"sources":["encode.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,IAAM,YAAY,GAAG,qCAArB;AAEA;;;;;;;;;;AAUG;;AACH,SAAgB,UAAhB,CAA2B,IAA3B,EAAuC;AACnC,SAAO,gBAAgB,CAAC,YAAD,EAAe,IAAf,CAAvB;AACH;;AAFD,OAAA,CAAA,UAAA,GAAA,UAAA;AAGA;;;;;;;AAOG;;AACH,SAAgB,kBAAhB,CAAmC,IAAnC,EAA+C;AAC3C,SAAO,gBAAgB,CAAC,WAAA,CAAA,WAAD,EAAc,IAAd,CAAvB;AACH;;AAFD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAIA,SAAS,gBAAT,CAA0B,MAA1B,EAA0C,GAA1C,EAAqD;AACjD,MAAI,GAAG,GAAG,EAAV;AACA,MAAI,OAAO,GAAG,CAAd;AACA,MAAI,KAAJ;;AAEA,SAAO,CAAC,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAT,MAA+B,IAAtC,EAA4C;AACxC,QAAM,CAAC,GAAG,KAAK,CAAC,KAAhB;AACA,IAAA,GAAG,IAAI,GAAG,CAAC,SAAJ,CAAc,OAAd,EAAuB,CAAvB,CAAP;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAf,CAAb;AACA,QAAI,IAAI,GAAG,gBAAA,CAAA,OAAA,CAAS,GAAT,CAAa,IAAb,CAAX;;AAEA,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B;AACA,UAAI,CAAC,GAAG,CAAJ,GAAQ,GAAG,CAAC,MAAhB,EAAwB;AACpB,YAAM,QAAQ,GAAG,GAAG,CAAC,UAAJ,CAAe,CAAC,GAAG,CAAnB,CAAjB;AACA,YAAM,KAAK,GACP,OAAO,IAAI,CAAC,CAAZ,KAAkB,QAAlB,GACM,IAAI,CAAC,CAAL,KAAW,QAAX,GACI,IAAI,CAAC,CADT,GAEI,SAHV,GAIM,IAAI,CAAC,CAAL,CAAO,GAAP,CAAW,QAAX,CALV;;AAOA,YAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,UAAA,GAAG,IAAI,KAAP;AACA,UAAA,OAAO,GAAG,MAAM,CAAC,SAAP,IAAoB,CAA9B;AACA;AACH;AACJ;;AAED,MAAA,IAAI,GAAG,IAAI,CAAC,CAAZ;AACH,KAzBuC,CA2BxC;;;AACA,QAAI,IAAI,KAAK,SAAb,EAAwB;AACpB,MAAA,GAAG,IAAI,IAAP;AACA,MAAA,OAAO,GAAG,CAAC,GAAG,CAAd;AACH,KAHD,MAGO;AACH,UAAM,EAAE,GAAG,CAAA,GAAA,WAAA,CAAA,YAAA,EAAa,GAAb,EAAkB,CAAlB,CAAX;AACA,MAAA,GAAG,IAAI,MAAA,MAAA,CAAM,EAAE,CAAC,QAAH,CAAY,EAAZ,CAAN,EAAqB,GAArB,CAAP,CAFG,CAGH;;AACA,MAAA,OAAO,GAAG,MAAM,CAAC,SAAP,IAAoB,MAAM,CAAC,EAAE,KAAK,IAAR,CAApC;AACH;AACJ;;AAED,SAAO,GAAG,GAAG,GAAG,CAAC,MAAJ,CAAW,OAAX,CAAb;AACH","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/61afd4701eaa736978b13c7351cd3de9a96b04bc/src/","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeNonAsciiHTML = exports.encodeHTML = void 0;\nvar encode_html_js_1 = __importDefault(require(\"./generated/encode-html.js\"));\nvar escape_js_1 = require(\"./escape.js\");\nvar htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeHTML(data) {\n    return encodeHTMLTrieRe(htmlReplacer, data);\n}\nexports.encodeHTML = encodeHTML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeNonAsciiHTML(data) {\n    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);\n}\nexports.encodeNonAsciiHTML = encodeNonAsciiHTML;\nfunction encodeHTMLTrieRe(regExp, str) {\n    var ret = \"\";\n    var lastIdx = 0;\n    var match;\n    while ((match = regExp.exec(str)) !== null) {\n        var i = match.index;\n        ret += str.substring(lastIdx, i);\n        var char = str.charCodeAt(i);\n        var next = encode_html_js_1.default.get(char);\n        if (typeof next === \"object\") {\n            // We are in a branch. Try to match the next char.\n            if (i + 1 < str.length) {\n                var nextChar = str.charCodeAt(i + 1);\n                var value = typeof next.n === \"number\"\n                    ? next.n === nextChar\n                        ? next.o\n                        : undefined\n                    : next.n.get(nextChar);\n                if (value !== undefined) {\n                    ret += value;\n                    lastIdx = regExp.lastIndex += 1;\n                    continue;\n                }\n            }\n            next = next.v;\n        }\n        // We might have a tree node without a value; skip and use a numeric entity.\n        if (next !== undefined) {\n            ret += next;\n            lastIdx = i + 1;\n        }\n        else {\n            var cp = (0, escape_js_1.getCodePoint)(str, i);\n            ret += \"&#x\".concat(cp.toString(16), \";\");\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = regExp.lastIndex += Number(cp !== char);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n//# sourceMappingURL=encode.js.map"]},"metadata":{},"sourceType":"script"}