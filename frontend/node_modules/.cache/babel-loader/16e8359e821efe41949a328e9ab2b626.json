{"ast":null,"code":"// Paragraph\nexport default function paragraph(state, startLine, endLine) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph');\n  const oldParentType = state.parentType;\n  let nextLine = startLine + 1;\n  state.parentType = 'paragraph'; // jump line-by-line until empty one or EOF\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    } // Some tags can terminate paragraph without empty line.\n\n\n    let terminate = false;\n\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  const token_o = state.push('paragraph_open', 'p', 1);\n  token_o.map = [startLine, state.line];\n  const token_i = state.push('inline', '', 0);\n  token_i.content = content;\n  token_i.map = [startLine, state.line];\n  token_i.children = [];\n  state.push('paragraph_close', 'p', -1);\n  state.parentType = oldParentType;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/paragraph.mjs"],"names":["paragraph","state","startLine","endLine","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","nextLine","isEmpty","sCount","blkIndent","terminate","i","l","length","content","getLines","trim","line","token_o","push","map","token_i","children"],"mappings":"AAAA;AAEA,eAAe,SAASA,SAAT,CAAoBC,KAApB,EAA2BC,SAA3B,EAAsCC,OAAtC,EAA+C;AAC5D,QAAMC,eAAe,GAAGH,KAAK,CAACI,EAAN,CAASC,KAAT,CAAeC,KAAf,CAAqBC,QAArB,CAA8B,WAA9B,CAAxB;AACA,QAAMC,aAAa,GAAGR,KAAK,CAACS,UAA5B;AACA,MAAIC,QAAQ,GAAGT,SAAS,GAAG,CAA3B;AACAD,EAAAA,KAAK,CAACS,UAAN,GAAmB,WAAnB,CAJ4D,CAM5D;;AACA,SAAOC,QAAQ,GAAGR,OAAX,IAAsB,CAACF,KAAK,CAACW,OAAN,CAAcD,QAAd,CAA9B,EAAuDA,QAAQ,EAA/D,EAAmE;AACjE;AACA;AACA,QAAIV,KAAK,CAACY,MAAN,CAAaF,QAAb,IAAyBV,KAAK,CAACa,SAA/B,GAA2C,CAA/C,EAAkD;AAAE;AAAU,KAHG,CAKjE;;;AACA,QAAIb,KAAK,CAACY,MAAN,CAAaF,QAAb,IAAyB,CAA7B,EAAgC;AAAE;AAAU,KANqB,CAQjE;;;AACA,QAAII,SAAS,GAAG,KAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGb,eAAe,CAACc,MAApC,EAA4CF,CAAC,GAAGC,CAAhD,EAAmDD,CAAC,EAApD,EAAwD;AACtD,UAAIZ,eAAe,CAACY,CAAD,CAAf,CAAmBf,KAAnB,EAA0BU,QAA1B,EAAoCR,OAApC,EAA6C,IAA7C,CAAJ,EAAwD;AACtDY,QAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AACD,QAAIA,SAAJ,EAAe;AAAE;AAAO;AACzB;;AAED,QAAMI,OAAO,GAAGlB,KAAK,CAACmB,QAAN,CAAelB,SAAf,EAA0BS,QAA1B,EAAoCV,KAAK,CAACa,SAA1C,EAAqD,KAArD,EAA4DO,IAA5D,EAAhB;AAEApB,EAAAA,KAAK,CAACqB,IAAN,GAAaX,QAAb;AAEA,QAAMY,OAAO,GAAMtB,KAAK,CAACuB,IAAN,CAAW,gBAAX,EAA6B,GAA7B,EAAkC,CAAlC,CAAnB;AACAD,EAAAA,OAAO,CAACE,GAAR,GAAmB,CAACvB,SAAD,EAAYD,KAAK,CAACqB,IAAlB,CAAnB;AAEA,QAAMI,OAAO,GAAMzB,KAAK,CAACuB,IAAN,CAAW,QAAX,EAAqB,EAArB,EAAyB,CAAzB,CAAnB;AACAE,EAAAA,OAAO,CAACP,OAAR,GAAmBA,OAAnB;AACAO,EAAAA,OAAO,CAACD,GAAR,GAAmB,CAACvB,SAAD,EAAYD,KAAK,CAACqB,IAAlB,CAAnB;AACAI,EAAAA,OAAO,CAACC,QAAR,GAAmB,EAAnB;AAEA1B,EAAAA,KAAK,CAACuB,IAAN,CAAW,iBAAX,EAA8B,GAA9B,EAAmC,CAAC,CAApC;AAEAvB,EAAAA,KAAK,CAACS,UAAN,GAAmBD,aAAnB;AAEA,SAAO,IAAP;AACD","sourcesContent":["// Paragraph\n\nexport default function paragraph (state, startLine, endLine) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph')\n  const oldParentType = state.parentType\n  let nextLine = startLine + 1\n  state.parentType = 'paragraph'\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n\n  state.line = nextLine\n\n  const token_o    = state.push('paragraph_open', 'p', 1)\n  token_o.map      = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = content\n  token_i.map      = [startLine, state.line]\n  token_i.children = []\n\n  state.push('paragraph_close', 'p', -1)\n\n  state.parentType = oldParentType\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}