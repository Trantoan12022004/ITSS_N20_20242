{"ast":null,"code":"// Inline parser state\nimport Token from '../token.mjs';\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs';\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n\n  this.cache = {}; // List of emphasis-like delimiters for current tag\n\n  this.delimiters = []; // Stack of delimiter lists for upper level tags\n\n  this._prev_delimiters = []; // backtick length => last seen position\n\n  this.backticks = {};\n  this.backticksScanned = false; // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n\n  this.linkLevel = 0;\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  const token = new Token(type, tag, nesting);\n  let token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n\n    this._prev_delimiters.push(this.delimiters);\n\n    this.delimiters = [];\n    token_meta = {\n      delimiters: this.delimiters\n    };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n}; // Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\n\n\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax;\n  const marker = this.src.charCodeAt(start); // treat beginning of the line as a whitespace\n\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n  let pos = start;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  const count = pos - start; // treat end of the line as a whitespace\n\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  const isLastWhiteSpace = isWhiteSpace(lastChar);\n  const isNextWhiteSpace = isWhiteSpace(nextChar);\n  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);\n  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);\n  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);\n  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);\n  return {\n    can_open,\n    can_close,\n    length: count\n  };\n}; // re-export Token class to use in block rules\n\n\nStateInline.prototype.Token = Token;\nexport default StateInline;","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_inline/state_inline.mjs"],"names":["Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","backticks","backticksScanned","linkLevel","prototype","pushPending","token","content","push","type","tag","nesting","token_meta","pop","scanDelims","start","canSplitWord","max","marker","charCodeAt","lastChar","count","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","left_flanking","right_flanking","can_open","can_close"],"mappings":"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","sourcesContent":["// Inline parser state\n\nimport Token from '../token.mjs'\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new Token(type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = isWhiteSpace(lastChar)\n  const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n  const left_flanking =\n    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)\n  const right_flanking =\n    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)\n\n  const can_open  = left_flanking  && (canSplitWord || !right_flanking || isLastPunctChar)\n  const can_close = right_flanking && (canSplitWord || !left_flanking  || isNextPunctChar)\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token\n\nexport default StateInline\n"]},"metadata":{},"sourceType":"module"}