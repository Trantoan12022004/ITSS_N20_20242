{"ast":null,"code":"import { isSpace, normalizeReference } from '../common/utils.mjs';\nexport default function reference(state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n  let nextLine = startLine + 1; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  function getNextLine(nextLine) {\n    const endLine = state.lineMax;\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null;\n    }\n\n    let isContinuation = false; // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      isContinuation = true;\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      isContinuation = true;\n    }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference');\n      const oldParentType = state.parentType;\n      state.parentType = 'reference'; // Some tags can terminate paragraph without empty line.\n\n      let terminate = false;\n\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n\n      state.parentType = oldParentType;\n\n      if (terminate) {\n        // terminated by another block\n        return null;\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    const max = state.eMarks[nextLine]; // max + 1 explicitly includes the newline\n\n    return state.src.slice(pos, max + 1);\n  }\n\n  let str = state.src.slice(pos, max + 1);\n  max = str.length;\n  let labelEnd = -1;\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n\n    if (ch === 0x5B\n    /* [ */\n    ) {\n        return false;\n      } else if (ch === 0x5D\n    /* ] */\n    ) {\n        labelEnd = pos;\n        break;\n      } else if (ch === 0x0A\n    /* \\n */\n    ) {\n        const lineContent = getNextLine(nextLine);\n\n        if (lineContent !== null) {\n          str += lineContent;\n          max = str.length;\n          nextLine++;\n        }\n      } else if (ch === 0x5C\n    /* \\ */\n    ) {\n        pos++;\n\n        if (pos < max && str.charCodeAt(pos) === 0x0A) {\n          const lineContent = getNextLine(nextLine);\n\n          if (lineContent !== null) {\n            str += lineContent;\n            max = str.length;\n            nextLine++;\n          }\n        }\n      }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return false;\n    } // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine);\n\n      if (lineContent !== null) {\n        str += lineContent;\n        max = str.length;\n        nextLine++;\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);\n\n  if (!destRes.ok) {\n    return false;\n  }\n\n  const href = state.md.normalizeLink(destRes.str);\n\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n\n  pos = destRes.pos; // save cursor state, we could require to rollback later\n\n  const destEndPos = pos;\n  const destEndLineNo = nextLine; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  const start = pos;\n\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine);\n\n      if (lineContent !== null) {\n        str += lineContent;\n        max = str.length;\n        nextLine++;\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);\n\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine);\n    if (lineContent === null) break;\n    str += lineContent;\n    pos = max;\n    max = str.length;\n    nextLine++;\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);\n  }\n\n  let title;\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str;\n    pos = titleRes.pos;\n  } else {\n    title = '';\n    pos = destEndPos;\n    nextLine = destEndLineNo;\n  } // skip trailing spaces until the rest of the line\n\n\n  while (pos < max) {\n    const ch = str.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      nextLine = destEndLineNo;\n\n      while (pos < max) {\n        const ch = str.charCodeAt(pos);\n\n        if (!isSpace(ch)) {\n          break;\n        }\n\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd));\n\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  } // Reference can not terminate anything. This check is for safety only.\n\n  /* istanbul ignore if */\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title,\n      href\n    };\n  }\n\n  state.line = nextLine;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/reference.mjs"],"names":["isSpace","normalizeReference","reference","state","startLine","_endLine","silent","pos","bMarks","tShift","max","eMarks","nextLine","sCount","blkIndent","src","charCodeAt","getNextLine","endLine","lineMax","isEmpty","isContinuation","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","terminate","i","l","length","slice","str","labelEnd","ch","lineContent","destRes","helpers","parseLinkDestination","ok","href","normalizeLink","validateLink","destEndPos","destEndLineNo","start","titleRes","parseLinkTitle","can_continue","title","label","env","references","line"],"mappings":"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","sourcesContent":["import { isSpace, normalizeReference } from '../common/utils.mjs'\n\nexport default function reference (state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  function getNextLine (nextLine) {\n    const endLine = state.lineMax\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null\n    }\n\n    let isContinuation = false\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { isContinuation = true }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { isContinuation = true }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference')\n      const oldParentType = state.parentType\n      state.parentType = 'reference'\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true\n          break\n        }\n      }\n\n      state.parentType = oldParentType\n      if (terminate) {\n        // terminated by another block\n        return null\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    const max = state.eMarks[nextLine]\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1)\n  }\n\n  let str = state.src.slice(pos, max + 1)\n\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine)\n        if (lineContent !== null) {\n          str += lineContent\n          max = str.length\n          nextLine++\n        }\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = nextLine\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine)\n    if (lineContent === null) break\n    str += lineContent\n    pos = max\n    max = str.length\n    nextLine++\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)\n  }\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n  } else {\n    title = ''\n    pos = destEndPos\n    nextLine = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      nextLine = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!isSpace(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.line = nextLine\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}