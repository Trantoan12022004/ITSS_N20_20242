{"ast":null,"code":"// fences (``` lang, ~~~ lang)\nexport default function fence(state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (pos + 3 > max) {\n    return false;\n  }\n\n  const marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x60\n  /* ` */\n  ) {\n      return false;\n    } // scan marker length\n\n\n  let mem = pos;\n  pos = state.skipChars(pos, marker);\n  let len = pos - mem;\n\n  if (len < 3) {\n    return false;\n  }\n\n  const markup = state.src.slice(mem, pos);\n  const params = state.src.slice(pos, max);\n\n  if (marker === 0x60\n  /* ` */\n  ) {\n      if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n        return false;\n      }\n    } // Since start is found, we can report success here in validation mode\n\n\n  if (silent) {\n    return true;\n  } // search end of block\n\n\n  let nextLine = startLine;\n  let haveEndMarker = false;\n\n  for (;;) {\n    nextLine++;\n\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one\n\n    if (pos - mem < len) {\n      continue;\n    } // make sure tail has spaces only\n\n\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) {\n      continue;\n    }\n\n    haveEndMarker = true; // found!\n\n    break;\n  } // If a fence has heading spaces, they should be removed from its inner block\n\n\n  len = state.sCount[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  const token = state.push('fence', 'code', 0);\n  token.info = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup = markup;\n  token.map = [startLine, state.line];\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/fence.mjs"],"names":["fence","state","startLine","endLine","silent","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","marker","src","charCodeAt","mem","skipChars","len","markup","slice","params","indexOf","String","fromCharCode","nextLine","haveEndMarker","skipSpaces","line","token","push","info","content","getLines","map"],"mappings":"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","sourcesContent":["// fences (``` lang, ~~~ lang)\n\nexport default function fence (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (pos + 3 > max) { return false }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) { return false }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true }\n\n  // search end of block\n  let nextLine = startLine\n  let haveEndMarker = false\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) { continue }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token   = state.push('fence', 'code', 0)\n  token.info    = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup  = markup\n  token.map     = [startLine, state.line]\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}