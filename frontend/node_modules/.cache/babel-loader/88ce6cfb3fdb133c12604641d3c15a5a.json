{"ast":null,"code":"// Process escaped chars and hardbreaks\nimport { isSpace } from '../common/utils.mjs';\nconst ESCAPED = [];\n\nfor (let i = 0; i < 256; i++) {\n  ESCAPED.push(0);\n}\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {\n  ESCAPED[ch.charCodeAt(0)] = 1;\n});\nexport default function escape(state, silent) {\n  let pos = state.pos;\n  const max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x5C\n  /* \\ */\n  ) return false;\n  pos++; // '\\' at the end of the inline block\n\n  if (pos >= max) return false;\n  let ch1 = state.src.charCodeAt(pos);\n\n  if (ch1 === 0x0A) {\n    if (!silent) {\n      state.push('hardbreak', 'br', 0);\n    }\n\n    pos++; // skip leading whitespaces from next line\n\n    while (pos < max) {\n      ch1 = state.src.charCodeAt(pos);\n      if (!isSpace(ch1)) break;\n      pos++;\n    }\n\n    state.pos = pos;\n    return true;\n  }\n\n  let escapedStr = state.src[pos];\n\n  if (ch1 >= 0xD800 && ch1 <= 0xDBFF && pos + 1 < max) {\n    const ch2 = state.src.charCodeAt(pos + 1);\n\n    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {\n      escapedStr += state.src[pos + 1];\n      pos++;\n    }\n  }\n\n  const origStr = '\\\\' + escapedStr;\n\n  if (!silent) {\n    const token = state.push('text_special', '', 0);\n\n    if (ch1 < 256 && ESCAPED[ch1] !== 0) {\n      token.content = escapedStr;\n    } else {\n      token.content = origStr;\n    }\n\n    token.markup = origStr;\n    token.info = 'escape';\n  }\n\n  state.pos = pos + 1;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_inline/escape.mjs"],"names":["isSpace","ESCAPED","i","push","split","forEach","ch","charCodeAt","escape","state","silent","pos","max","posMax","src","ch1","escapedStr","ch2","origStr","token","content","markup","info"],"mappings":"AAAA;AAEA,SAASA,OAAT,QAAwB,qBAAxB;AAEA,MAAMC,OAAO,GAAG,EAAhB;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAApB,EAAyBA,CAAC,EAA1B,EAA8B;AAAED,EAAAA,OAAO,CAACE,IAAR,CAAa,CAAb;AAAiB;;AAEjD,qCACGC,KADH,CACS,EADT,EACaC,OADb,CACqB,UAAUC,EAAV,EAAc;AAAEL,EAAAA,OAAO,CAACK,EAAE,CAACC,UAAH,CAAc,CAAd,CAAD,CAAP,GAA4B,CAA5B;AAA+B,CADpE;AAGA,eAAe,SAASC,MAAT,CAAiBC,KAAjB,EAAwBC,MAAxB,EAAgC;AAC7C,MAAIC,GAAG,GAAGF,KAAK,CAACE,GAAhB;AACA,QAAMC,GAAG,GAAGH,KAAK,CAACI,MAAlB;AAEA,MAAIJ,KAAK,CAACK,GAAN,CAAUP,UAAV,CAAqBI,GAArB,MAA8B;AAAI;AAAtC,IAA+C,OAAO,KAAP;AAC/CA,EAAAA,GAAG,GAL0C,CAO7C;;AACA,MAAIA,GAAG,IAAIC,GAAX,EAAgB,OAAO,KAAP;AAEhB,MAAIG,GAAG,GAAGN,KAAK,CAACK,GAAN,CAAUP,UAAV,CAAqBI,GAArB,CAAV;;AAEA,MAAII,GAAG,KAAK,IAAZ,EAAkB;AAChB,QAAI,CAACL,MAAL,EAAa;AACXD,MAAAA,KAAK,CAACN,IAAN,CAAW,WAAX,EAAwB,IAAxB,EAA8B,CAA9B;AACD;;AAEDQ,IAAAA,GAAG,GALa,CAMhB;;AACA,WAAOA,GAAG,GAAGC,GAAb,EAAkB;AAChBG,MAAAA,GAAG,GAAGN,KAAK,CAACK,GAAN,CAAUP,UAAV,CAAqBI,GAArB,CAAN;AACA,UAAI,CAACX,OAAO,CAACe,GAAD,CAAZ,EAAmB;AACnBJ,MAAAA,GAAG;AACJ;;AAEDF,IAAAA,KAAK,CAACE,GAAN,GAAYA,GAAZ;AACA,WAAO,IAAP;AACD;;AAED,MAAIK,UAAU,GAAGP,KAAK,CAACK,GAAN,CAAUH,GAAV,CAAjB;;AAEA,MAAII,GAAG,IAAI,MAAP,IAAiBA,GAAG,IAAI,MAAxB,IAAkCJ,GAAG,GAAG,CAAN,GAAUC,GAAhD,EAAqD;AACnD,UAAMK,GAAG,GAAGR,KAAK,CAACK,GAAN,CAAUP,UAAV,CAAqBI,GAAG,GAAG,CAA3B,CAAZ;;AAEA,QAAIM,GAAG,IAAI,MAAP,IAAiBA,GAAG,IAAI,MAA5B,EAAoC;AAClCD,MAAAA,UAAU,IAAIP,KAAK,CAACK,GAAN,CAAUH,GAAG,GAAG,CAAhB,CAAd;AACAA,MAAAA,GAAG;AACJ;AACF;;AAED,QAAMO,OAAO,GAAG,OAAOF,UAAvB;;AAEA,MAAI,CAACN,MAAL,EAAa;AACX,UAAMS,KAAK,GAAGV,KAAK,CAACN,IAAN,CAAW,cAAX,EAA2B,EAA3B,EAA+B,CAA/B,CAAd;;AAEA,QAAIY,GAAG,GAAG,GAAN,IAAad,OAAO,CAACc,GAAD,CAAP,KAAiB,CAAlC,EAAqC;AACnCI,MAAAA,KAAK,CAACC,OAAN,GAAgBJ,UAAhB;AACD,KAFD,MAEO;AACLG,MAAAA,KAAK,CAACC,OAAN,GAAgBF,OAAhB;AACD;;AAEDC,IAAAA,KAAK,CAACE,MAAN,GAAeH,OAAf;AACAC,IAAAA,KAAK,CAACG,IAAN,GAAe,QAAf;AACD;;AAEDb,EAAAA,KAAK,CAACE,GAAN,GAAYA,GAAG,GAAG,CAAlB;AACA,SAAO,IAAP;AACD","sourcesContent":["// Process escaped chars and hardbreaks\n\nimport { isSpace } from '../common/utils.mjs'\n\nconst ESCAPED = []\n\nfor (let i = 0; i < 256; i++) { ESCAPED.push(0) }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1 })\n\nexport default function escape (state, silent) {\n  let pos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) return false\n  pos++\n\n  // '\\' at the end of the inline block\n  if (pos >= max) return false\n\n  let ch1 = state.src.charCodeAt(pos)\n\n  if (ch1 === 0x0A) {\n    if (!silent) {\n      state.push('hardbreak', 'br', 0)\n    }\n\n    pos++\n    // skip leading whitespaces from next line\n    while (pos < max) {\n      ch1 = state.src.charCodeAt(pos)\n      if (!isSpace(ch1)) break\n      pos++\n    }\n\n    state.pos = pos\n    return true\n  }\n\n  let escapedStr = state.src[pos]\n\n  if (ch1 >= 0xD800 && ch1 <= 0xDBFF && pos + 1 < max) {\n    const ch2 = state.src.charCodeAt(pos + 1)\n\n    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {\n      escapedStr += state.src[pos + 1]\n      pos++\n    }\n  }\n\n  const origStr = '\\\\' + escapedStr\n\n  if (!silent) {\n    const token = state.push('text_special', '', 0)\n\n    if (ch1 < 256 && ESCAPED[ch1] !== 0) {\n      token.content = escapedStr\n    } else {\n      token.content = origStr\n    }\n\n    token.markup = origStr\n    token.info   = 'escape'\n  }\n\n  state.pos = pos + 1\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}