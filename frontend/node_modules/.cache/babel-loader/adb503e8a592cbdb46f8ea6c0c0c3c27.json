{"ast":null,"code":"// Process ![image](<src> \"title\")\nimport { normalizeReference, isSpace } from '../common/utils.mjs';\nexport default function image(state, silent) {\n  let code, content, label, pos, ref, res, title, start;\n  let href = '';\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21\n  /* ! */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n      //\n      // Inline link\n      //\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n      pos++;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (!isSpace(code) && code !== 0x0A) {\n          break;\n        }\n      }\n\n      if (pos >= max) {\n        return false;\n      } // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n\n\n      start = pos;\n      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n      if (res.ok) {\n        href = state.md.normalizeLink(res.str);\n\n        if (state.md.validateLink(href)) {\n          pos = res.pos;\n        } else {\n          href = '';\n        }\n      } // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n\n\n      start = pos;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (!isSpace(code) && code !== 0x0A) {\n          break;\n        }\n      } // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n\n\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos; // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n\n          if (!isSpace(code) && code !== 0x0A) {\n            break;\n          }\n        }\n      } else {\n        title = '';\n      }\n\n      if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n      /* ) */\n      ) {\n          state.pos = oldPos;\n          return false;\n        }\n\n      pos++;\n    } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n        start = pos + 1;\n        pos = state.md.helpers.parseLinkLabel(state, pos);\n\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = labelEnd + 1;\n        }\n      } else {\n      pos = labelEnd + 1;\n    } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n    const tokens = [];\n    state.md.inline.parse(content, state.md, state.env, tokens);\n    const token = state.push('image', 'img', 0);\n    const attrs = [['src', href], ['alt', '']];\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = content;\n\n    if (title) {\n      attrs.push(['title', title]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_inline/image.mjs"],"names":["normalizeReference","isSpace","image","state","silent","code","content","label","pos","ref","res","title","start","href","oldPos","max","posMax","src","charCodeAt","labelStart","labelEnd","md","helpers","parseLinkLabel","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLinkTitle","env","references","slice","tokens","inline","parse","token","push","attrs","children"],"mappings":"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","sourcesContent":["// Process ![image](<src> \"title\")\n\nimport { normalizeReference, isSpace } from '../common/utils.mjs'\n\nexport default function image (state, silent) {\n  let code, content, label, pos, ref, res, title, start\n  let href = ''\n  const oldPos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false }\n\n  const labelStart = state.pos + 2\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false }\n\n  pos = labelEnd + 1\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!isSpace(code) && code !== 0x0A) { break }\n    }\n    if (pos >= max) { return false }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str)\n      if (state.md.validateLink(href)) {\n        pos = res.pos\n      } else {\n        href = ''\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!isSpace(code) && code !== 0x0A) { break }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str\n      pos = res.pos\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos)\n        if (!isSpace(code) && code !== 0x0A) { break }\n      }\n    } else {\n      title = ''\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos\n      return false\n    }\n    pos++\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1\n      pos = state.md.helpers.parseLinkLabel(state, pos)\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++)\n      } else {\n        pos = labelEnd + 1\n      }\n    } else {\n      pos = labelEnd + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd) }\n\n    ref = state.env.references[normalizeReference(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd)\n\n    const tokens = []\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens\n    )\n\n    const token = state.push('image', 'img', 0)\n    const attrs = [['src', href], ['alt', '']]\n    token.attrs = attrs\n    token.children = tokens\n    token.content = content\n\n    if (title) {\n      attrs.push(['title', title])\n    }\n  }\n\n  state.pos = pos\n  state.posMax = max\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}