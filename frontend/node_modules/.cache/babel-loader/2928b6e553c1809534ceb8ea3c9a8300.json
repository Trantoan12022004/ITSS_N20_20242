{"ast":null,"code":"/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\nimport Ruler from './ruler.mjs';\nimport StateBlock from './rules_block/state_block.mjs';\nimport r_table from './rules_block/table.mjs';\nimport r_code from './rules_block/code.mjs';\nimport r_fence from './rules_block/fence.mjs';\nimport r_blockquote from './rules_block/blockquote.mjs';\nimport r_hr from './rules_block/hr.mjs';\nimport r_list from './rules_block/list.mjs';\nimport r_reference from './rules_block/reference.mjs';\nimport r_html_block from './rules_block/html_block.mjs';\nimport r_heading from './rules_block/heading.mjs';\nimport r_lheading from './rules_block/lheading.mjs';\nimport r_paragraph from './rules_block/paragraph.mjs';\nconst _rules = [// First 2 params - rule name & source. Secondary array - list of rules,\n// which can be terminated by this one.\n['table', r_table, ['paragraph', 'reference']], ['code', r_code], ['fence', r_fence, ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', r_blockquote, ['paragraph', 'reference', 'blockquote', 'list']], ['hr', r_hr, ['paragraph', 'reference', 'blockquote', 'list']], ['list', r_list, ['paragraph', 'reference', 'blockquote']], ['reference', r_reference], ['html_block', r_html_block, ['paragraph', 'reference', 'blockquote']], ['heading', r_heading, ['paragraph', 'reference', 'blockquote']], ['lheading', r_lheading], ['paragraph', r_paragraph]];\n/**\n * new ParserBlock()\n **/\n\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n} // Generate tokens for input range\n//\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  const rules = this.ruler.getRules('');\n  const len = rules.length;\n  const maxNesting = state.md.options.maxNesting;\n  let line = startLine;\n  let hasEmptyLines = false;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.sCount[line] < state.blkIndent) {\n      break;\n    } // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n\n\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    const prevLine = state.line;\n    let ok = false;\n\n    for (let i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\");\n        }\n\n        break;\n      }\n    } // this can only happen if user disables paragraph rule\n\n\n    if (!ok) throw new Error('none of the block rules matched'); // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\n\n\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  if (!src) {\n    return;\n  }\n\n  const state = new this.State(src, md, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\nParserBlock.prototype.State = StateBlock;\nexport default ParserBlock;","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/parser_block.mjs"],"names":["Ruler","StateBlock","r_table","r_code","r_fence","r_blockquote","r_hr","r_list","r_reference","r_html_block","r_heading","r_lheading","r_paragraph","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","rules","getRules","len","maxNesting","md","options","line","hasEmptyLines","skipEmptyLines","sCount","blkIndent","level","prevLine","ok","Error","tight","isEmpty","parse","src","env","outTokens","State","lineMax"],"mappings":"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","sourcesContent":["/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\nimport Ruler from './ruler.mjs'\nimport StateBlock from './rules_block/state_block.mjs'\n\nimport r_table from './rules_block/table.mjs'\nimport r_code from './rules_block/code.mjs'\nimport r_fence from './rules_block/fence.mjs'\nimport r_blockquote from './rules_block/blockquote.mjs'\nimport r_hr from './rules_block/hr.mjs'\nimport r_list from './rules_block/list.mjs'\nimport r_reference from './rules_block/reference.mjs'\nimport r_html_block from './rules_block/html_block.mjs'\nimport r_heading from './rules_block/heading.mjs'\nimport r_lheading from './rules_block/lheading.mjs'\nimport r_paragraph from './rules_block/paragraph.mjs'\n\nconst _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  ['table',      r_table,      ['paragraph', 'reference']],\n  ['code',       r_code],\n  ['fence',      r_fence,      ['paragraph', 'reference', 'blockquote', 'list']],\n  ['blockquote', r_blockquote, ['paragraph', 'reference', 'blockquote', 'list']],\n  ['hr',         r_hr,         ['paragraph', 'reference', 'blockquote', 'list']],\n  ['list',       r_list,       ['paragraph', 'reference', 'blockquote']],\n  ['reference',  r_reference],\n  ['html_block', r_html_block, ['paragraph', 'reference', 'blockquote']],\n  ['heading',    r_heading,    ['paragraph', 'reference', 'blockquote']],\n  ['lheading',   r_lheading],\n  ['paragraph',  r_paragraph]\n]\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock () {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() })\n  }\n}\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  let line = startLine\n  let hasEmptyLines = false\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line)\n    if (line >= endLine) { break }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine\n      break\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    const prevLine = state.line\n    let ok = false\n\n    for (let i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false)\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\")\n        }\n        break\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched')\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true\n    }\n\n    line = state.line\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true\n      line++\n      state.line = line\n    }\n  }\n}\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  if (!src) { return }\n\n  const state = new this.State(src, md, env, outTokens)\n\n  this.tokenize(state, state.line, state.lineMax)\n}\n\nParserBlock.prototype.State = StateBlock\n\nexport default ParserBlock\n"]},"metadata":{},"sourceType":"module"}