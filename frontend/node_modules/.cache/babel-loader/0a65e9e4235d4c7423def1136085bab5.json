{"ast":null,"code":"'use strict';\n/* eslint-disable no-bitwise */\n\nconst decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  let cache = decodeCache[exclude];\n\n  if (cache) {\n    return cache;\n  }\n\n  cache = decodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    const ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n} // Decode percent-encoded string.\n//\n\n\nfunction decode(string, exclude) {\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  const cache = getDecodeCache(exclude);\n  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n    let result = '';\n\n    for (let i = 0, l = seq.length; i < l; i += 3) {\n      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {\n        // 110xxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          const chr = b1 << 6 & 0x7C0 | b2 & 0x3F;\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          const chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;\n\n          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          let chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\ndecode.defaultChars = ';/?:@&=+$,#';\ndecode.componentChars = '';\nconst encodeCache = {}; // Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\n\nfunction getEncodeCache(exclude) {\n  let cache = encodeCache[exclude];\n\n  if (cache) {\n    return cache;\n  }\n\n  cache = encodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n} // Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\n\n\nfunction encode(string, exclude, keepEscaped) {\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  const cache = getEncodeCache(exclude);\n  let result = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25\n    /* % */\n    && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        const nextCode = string.charCodeAt(i + 1);\n\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\nfunction format(url) {\n  let result = '';\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n  return result;\n} // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n} // Reference: RFC 3986, RFC 1808, RFC 2396\n// define these here so at least they only have to be\n// compiled once on the first module load.\n\n\nconst protocolPattern = /^([a-z0-9.+-]+:)/i;\nconst portPattern = /:[0-9]*$/; // Special case for a simple path URL\n\n/* eslint-disable-next-line no-useless-escape */\n\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/; // RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\n\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t']; // RFC 2396: characters not allowed for various reasons.\n\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims); // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n\nconst autoEscape = ['\\''].concat(unwise); // Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\n\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\nconst hostEndingChars = ['/', '?', '#'];\nconst hostnameMaxLen = 255;\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/; // protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\n\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n}; // protocols that always contain a // bit.\n\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url;\n  const u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes;\n  let rest = url; // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n\n    if (simplePath) {\n      this.pathname = simplePath[1];\n\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n\n      return this;\n    }\n  }\n\n  let proto = protocolPattern.exec(rest);\n\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  } // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n\n  /* eslint-disable-next-line no-useless-escape */\n\n\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1;\n\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    } // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n\n\n    let auth, atSign;\n\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    } // Now we have a portion which is definitely the auth.\n    // Pull that off.\n\n\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    } // the host is the remaining to the left of the first non-host char\n\n\n    hostEnd = -1;\n\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    } // if we still have not hit it, then the entire thing is a host.\n\n\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') {\n      hostEnd--;\n    }\n\n    const host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd); // pull out port.\n\n    this.parseHost(host); // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n\n    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n\n    const ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./);\n\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i];\n\n        if (!part) {\n          continue;\n        }\n\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = '';\n\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          } // we test again with ASCII char only\n\n\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i);\n            const notHost = hostparts.slice(i + 1);\n            const bit = part.match(hostnamePartStart);\n\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } // strip [ and ] from the hostname\n    // the host field still retains them, though\n\n\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  } // chop off from the tail first.\n\n\n  const hash = rest.indexOf('#');\n\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n\n  const qm = rest.indexOf('?');\n\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n\n  if (rest) {\n    this.pathname = rest;\n  }\n\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host);\n\n  if (port) {\n    port = port[0];\n\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n\n    host = host.substr(0, host.length - port.length);\n  }\n\n  if (host) {\n    this.hostname = host;\n  }\n};\n\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.parse = urlParse;","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/mdurl/build/index.cjs.js"],"names":["decodeCache","getDecodeCache","exclude","cache","i","ch","String","fromCharCode","push","length","charCodeAt","toString","toUpperCase","slice","decode","string","defaultChars","replace","seq","result","l","b1","parseInt","b2","chr","b3","b4","componentChars","encodeCache","getEncodeCache","test","encode","keepEscaped","code","nextCode","encodeURIComponent","format","url","protocol","slashes","auth","hostname","indexOf","port","pathname","search","hash","Url","protocolPattern","portPattern","simplePathPattern","delims","unwise","concat","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","hostlessProtocol","javascript","slashedProtocol","http","https","ftp","gopher","file","urlParse","slashesDenoteHost","u","parse","prototype","lowerProto","hec","rest","trim","split","simplePath","exec","proto","toLowerCase","substr","match","hostEnd","atSign","lastIndexOf","host","parseHost","ipv6Hostname","hostparts","part","newpart","j","k","validParts","notHost","bit","unshift","join","qm","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable no-bitwise */\n\nconst decodeCache = {};\n\nfunction getDecodeCache (exclude) {\n  let cache = decodeCache[exclude];\n  if (cache) { return cache }\n\n  cache = decodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    const ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache\n}\n\n// Decode percent-encoded string.\n//\nfunction decode (string, exclude) {\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  const cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n    let result = '';\n\n    for (let i = 0, l = seq.length; i < l; i += 3) {\n      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          const chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          const chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          let chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result\n  })\n}\n\ndecode.defaultChars = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\nconst encodeCache = {};\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache (exclude) {\n  let cache = encodeCache[exclude];\n  if (cache) { return cache }\n\n  cache = encodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache\n}\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode (string, exclude, keepEscaped) {\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  const cache = getEncodeCache(exclude);\n  let result = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        const nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue\n        }\n      }\n      result += '%EF%BF%BD';\n      continue\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result\n}\n\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\nfunction format (url) {\n  let result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result\n}\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\nfunction Url () {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i;\nconst portPattern = /:[0-9]*$/;\n\n// Special case for a simple path URL\n/* eslint-disable-next-line no-useless-escape */\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'];\n\n// RFC 2396: characters not allowed for various reasons.\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims);\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nconst autoEscape = ['\\''].concat(unwise);\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\nconst hostEndingChars = ['/', '?', '#'];\nconst hostnameMaxLen = 255;\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n};\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\nfunction urlParse (url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url\n\n  const u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u\n}\n\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes;\n  let rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this\n    }\n  }\n\n  let proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  /* eslint-disable-next-line no-useless-escape */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1;\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    let auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    const host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./);\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i];\n        if (!part) { continue }\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = '';\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i);\n            const notHost = hostparts.slice(i + 1);\n            const bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  const hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  const qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this\n};\n\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.parse = urlParse;\n"]},"metadata":{},"sourceType":"script"}