{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;\n\nvar decode_data_html_js_1 = __importDefault(require(\"./generated/decode-data-html.js\"));\n\nexports.htmlDecodeTree = decode_data_html_js_1.default;\n\nvar decode_data_xml_js_1 = __importDefault(require(\"./generated/decode-data-xml.js\"));\n\nexports.xmlDecodeTree = decode_data_xml_js_1.default;\n\nvar decode_codepoint_js_1 = __importStar(require(\"./decode_codepoint.js\"));\n\nexports.decodeCodePoint = decode_codepoint_js_1.default;\n\nvar decode_codepoint_js_2 = require(\"./decode_codepoint.js\");\n\nObject.defineProperty(exports, \"replaceCodePoint\", {\n  enumerable: true,\n  get: function () {\n    return decode_codepoint_js_2.replaceCodePoint;\n  }\n});\nObject.defineProperty(exports, \"fromCodePoint\", {\n  enumerable: true,\n  get: function () {\n    return decode_codepoint_js_2.fromCodePoint;\n  }\n});\nvar CharCodes;\n\n(function (CharCodes) {\n  CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n  CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n  CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n  CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n  CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n  CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n  CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n  CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n  CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n  CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n  CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n  CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\n\n\nvar TO_LOWER_BIT = 32;\nvar BinTrieFlags;\n\n(function (BinTrieFlags) {\n  BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));\n\nfunction isNumber(code) {\n  return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\n\nfunction isHexadecimalCharacter(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;\n}\n\nfunction isAsciiAlphaNumeric(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\n\n\nfunction isEntityInAttributeInvalidEnd(code) {\n  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\n\nvar EntityDecoderState;\n\n(function (EntityDecoderState) {\n  EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n  EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n  EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\n\nvar DecodingMode;\n\n(function (DecodingMode) {\n  /** Entities in text nodes that can end with any character. */\n  DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n  /** Only allow entities terminated with a semicolon. */\n\n  DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n  /** Entities in attributes have limitations on ending characters. */\n\n  DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\n\n\nvar EntityDecoder =\n/** @class */\nfunction () {\n  function EntityDecoder(\n  /** The tree used to decode entities. */\n  decodeTree,\n  /**\n   * The function that is called when a codepoint is decoded.\n   *\n   * For multi-byte named entities, this will be called multiple times,\n   * with the second codepoint, and the same `consumed` value.\n   *\n   * @param codepoint The decoded codepoint.\n   * @param consumed The number of bytes consumed by the decoder.\n   */\n  emitCodePoint,\n  /** An object that is used to produce errors. */\n  errors) {\n    this.decodeTree = decodeTree;\n    this.emitCodePoint = emitCodePoint;\n    this.errors = errors;\n    /** The current state of the decoder. */\n\n    this.state = EntityDecoderState.EntityStart;\n    /** Characters that were consumed while parsing an entity. */\n\n    this.consumed = 1;\n    /**\n     * The result of the entity.\n     *\n     * Either the result index of a numeric entity, or the codepoint of a\n     * numeric entity.\n     */\n\n    this.result = 0;\n    /** The current index in the decode tree. */\n\n    this.treeIndex = 0;\n    /** The number of characters that were consumed in excess. */\n\n    this.excess = 1;\n    /** The mode in which the decoder is operating. */\n\n    this.decodeMode = DecodingMode.Strict;\n  }\n  /** Resets the instance to make it reusable. */\n\n\n  EntityDecoder.prototype.startEntity = function (decodeMode) {\n    this.decodeMode = decodeMode;\n    this.state = EntityDecoderState.EntityStart;\n    this.result = 0;\n    this.treeIndex = 0;\n    this.excess = 1;\n    this.consumed = 1;\n  };\n  /**\n   * Write an entity to the decoder. This can be called multiple times with partial entities.\n   * If the entity is incomplete, the decoder will return -1.\n   *\n   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n   * entity is incomplete, and resume when the next string is written.\n   *\n   * @param string The string containing the entity (or a continuation of the entity).\n   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n\n\n  EntityDecoder.prototype.write = function (str, offset) {\n    switch (this.state) {\n      case EntityDecoderState.EntityStart:\n        {\n          if (str.charCodeAt(offset) === CharCodes.NUM) {\n            this.state = EntityDecoderState.NumericStart;\n            this.consumed += 1;\n            return this.stateNumericStart(str, offset + 1);\n          }\n\n          this.state = EntityDecoderState.NamedEntity;\n          return this.stateNamedEntity(str, offset);\n        }\n\n      case EntityDecoderState.NumericStart:\n        {\n          return this.stateNumericStart(str, offset);\n        }\n\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.stateNumericDecimal(str, offset);\n        }\n\n      case EntityDecoderState.NumericHex:\n        {\n          return this.stateNumericHex(str, offset);\n        }\n\n      case EntityDecoderState.NamedEntity:\n        {\n          return this.stateNamedEntity(str, offset);\n        }\n    }\n  };\n  /**\n   * Switches between the numeric decimal and hexadecimal states.\n   *\n   * Equivalent to the `Numeric character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n\n\n  EntityDecoder.prototype.stateNumericStart = function (str, offset) {\n    if (offset >= str.length) {\n      return -1;\n    }\n\n    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n      this.state = EntityDecoderState.NumericHex;\n      this.consumed += 1;\n      return this.stateNumericHex(str, offset + 1);\n    }\n\n    this.state = EntityDecoderState.NumericDecimal;\n    return this.stateNumericDecimal(str, offset);\n  };\n\n  EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {\n    if (start !== end) {\n      var digitCount = end - start;\n      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);\n      this.consumed += digitCount;\n    }\n  };\n  /**\n   * Parses a hexadecimal numeric entity.\n   *\n   * Equivalent to the `Hexademical character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n\n\n  EntityDecoder.prototype.stateNumericHex = function (str, offset) {\n    var startIdx = offset;\n\n    while (offset < str.length) {\n      var char = str.charCodeAt(offset);\n\n      if (isNumber(char) || isHexadecimalCharacter(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return this.emitNumericEntity(char, 3);\n      }\n    }\n\n    this.addToNumericResult(str, startIdx, offset, 16);\n    return -1;\n  };\n  /**\n   * Parses a decimal numeric entity.\n   *\n   * Equivalent to the `Decimal character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n\n\n  EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {\n    var startIdx = offset;\n\n    while (offset < str.length) {\n      var char = str.charCodeAt(offset);\n\n      if (isNumber(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return this.emitNumericEntity(char, 2);\n      }\n    }\n\n    this.addToNumericResult(str, startIdx, offset, 10);\n    return -1;\n  };\n  /**\n   * Validate and emit a numeric entity.\n   *\n   * Implements the logic from the `Hexademical character reference start\n   * state` and `Numeric character reference end state` in the HTML spec.\n   *\n   * @param lastCp The last code point of the entity. Used to see if the\n   *               entity was terminated with a semicolon.\n   * @param expectedLength The minimum number of characters that should be\n   *                       consumed. Used to validate that at least one digit\n   *                       was consumed.\n   * @returns The number of characters that were consumed.\n   */\n\n\n  EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {\n    var _a; // Ensure we consumed at least one digit.\n\n\n    if (this.consumed <= expectedLength) {\n      (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n      return 0;\n    } // Figure out if this is a legit end of the entity\n\n\n    if (lastCp === CharCodes.SEMI) {\n      this.consumed += 1;\n    } else if (this.decodeMode === DecodingMode.Strict) {\n      return 0;\n    }\n\n    this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);\n\n    if (this.errors) {\n      if (lastCp !== CharCodes.SEMI) {\n        this.errors.missingSemicolonAfterCharacterReference();\n      }\n\n      this.errors.validateNumericCharacterReference(this.result);\n    }\n\n    return this.consumed;\n  };\n  /**\n   * Parses a named entity.\n   *\n   * Equivalent to the `Named character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n\n\n  EntityDecoder.prototype.stateNamedEntity = function (str, offset) {\n    var decodeTree = this.decodeTree;\n    var current = decodeTree[this.treeIndex]; // The mask is the number of bytes of the value, including the current byte.\n\n    var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n\n    for (; offset < str.length; offset++, this.excess++) {\n      var char = str.charCodeAt(offset);\n      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n\n      if (this.treeIndex < 0) {\n        return this.result === 0 || // If we are parsing an attribute\n        this.decodeMode === DecodingMode.Attribute && ( // We shouldn't have consumed any characters after the entity,\n        valueLength === 0 || // And there should be no invalid characters.\n        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();\n      }\n\n      current = decodeTree[this.treeIndex];\n      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14; // If the branch is a value, store it and continue\n\n      if (valueLength !== 0) {\n        // If the entity is terminated by a semicolon, we are done.\n        if (char === CharCodes.SEMI) {\n          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n        } // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n\n\n        if (this.decodeMode !== DecodingMode.Strict) {\n          this.result = this.treeIndex;\n          this.consumed += this.excess;\n          this.excess = 0;\n        }\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Emit a named entity that was not terminated with a semicolon.\n   *\n   * @returns The number of characters consumed.\n   */\n\n\n  EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {\n    var _a;\n\n    var _b = this,\n        result = _b.result,\n        decodeTree = _b.decodeTree;\n\n    var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n    this.emitNamedEntityData(result, valueLength, this.consumed);\n    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n    return this.consumed;\n  };\n  /**\n   * Emit a named entity.\n   *\n   * @param result The index of the entity in the decode tree.\n   * @param valueLength The number of bytes in the entity.\n   * @param consumed The number of characters consumed.\n   *\n   * @returns The number of characters consumed.\n   */\n\n\n  EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {\n    var decodeTree = this.decodeTree;\n    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);\n\n    if (valueLength === 3) {\n      // For multi-byte values, we need to emit the second byte.\n      this.emitCodePoint(decodeTree[result + 2], consumed);\n    }\n\n    return consumed;\n  };\n  /**\n   * Signal to the parser that the end of the input was reached.\n   *\n   * Remaining data will be emitted and relevant errors will be produced.\n   *\n   * @returns The number of characters consumed.\n   */\n\n\n  EntityDecoder.prototype.end = function () {\n    var _a;\n\n    switch (this.state) {\n      case EntityDecoderState.NamedEntity:\n        {\n          // Emit a named entity if we have one.\n          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;\n        }\n      // Otherwise, emit a numeric entity if we have one.\n\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.emitNumericEntity(0, 2);\n        }\n\n      case EntityDecoderState.NumericHex:\n        {\n          return this.emitNumericEntity(0, 3);\n        }\n\n      case EntityDecoderState.NumericStart:\n        {\n          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n          return 0;\n        }\n\n      case EntityDecoderState.EntityStart:\n        {\n          // Return 0 if we have no entity.\n          return 0;\n        }\n    }\n  };\n\n  return EntityDecoder;\n}();\n\nexports.EntityDecoder = EntityDecoder;\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\n\nfunction getDecoder(decodeTree) {\n  var ret = \"\";\n  var decoder = new EntityDecoder(decodeTree, function (str) {\n    return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);\n  });\n  return function decodeWithTrie(str, decodeMode) {\n    var lastIndex = 0;\n    var offset = 0;\n\n    while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n      ret += str.slice(lastIndex, offset);\n      decoder.startEntity(decodeMode);\n      var len = decoder.write(str, // Skip the \"&\"\n      offset + 1);\n\n      if (len < 0) {\n        lastIndex = offset + decoder.end();\n        break;\n      }\n\n      lastIndex = offset + len; // If `len` is 0, skip the current `&` and continue.\n\n      offset = len === 0 ? lastIndex + 1 : lastIndex;\n    }\n\n    var result = ret + str.slice(lastIndex); // Make sure we don't keep a reference to the final string.\n\n    ret = \"\";\n    return result;\n  };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\n\n\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n  var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n  var jumpOffset = current & BinTrieFlags.JUMP_TABLE; // Case 1: Single branch encoded in jump offset\n\n  if (branchCount === 0) {\n    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n  } // Case 2: Multiple branches encoded in jump table\n\n\n  if (jumpOffset) {\n    var value = char - jumpOffset;\n    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;\n  } // Case 3: Multiple branches encoded in dictionary\n  // Binary search for the character.\n\n\n  var lo = nodeIdx;\n  var hi = lo + branchCount - 1;\n\n  while (lo <= hi) {\n    var mid = lo + hi >>> 1;\n    var midVal = decodeTree[mid];\n\n    if (midVal < char) {\n      lo = mid + 1;\n    } else if (midVal > char) {\n      hi = mid - 1;\n    } else {\n      return decodeTree[mid + branchCount];\n    }\n  }\n\n  return -1;\n}\n\nexports.determineBranch = determineBranch;\nvar htmlDecoder = getDecoder(decode_data_html_js_1.default);\nvar xmlDecoder = getDecoder(decode_data_xml_js_1.default);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\n\nfunction decodeHTML(str, mode) {\n  if (mode === void 0) {\n    mode = DecodingMode.Legacy;\n  }\n\n  return htmlDecoder(str, mode);\n}\n\nexports.decodeHTML = decodeHTML;\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeHTMLAttribute(str) {\n  return htmlDecoder(str, DecodingMode.Attribute);\n}\n\nexports.decodeHTMLAttribute = decodeHTMLAttribute;\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeHTMLStrict(str) {\n  return htmlDecoder(str, DecodingMode.Strict);\n}\n\nexports.decodeHTMLStrict = decodeHTMLStrict;\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeXML(str) {\n  return xmlDecoder(str, DecodingMode.Strict);\n}\n\nexports.decodeXML = decodeXML;","map":{"version":3,"sources":["decode.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/61afd4701eaa736978b13c7351cd3de9a96b04bc/src/","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;\nvar decode_data_html_js_1 = __importDefault(require(\"./generated/decode-data-html.js\"));\nexports.htmlDecodeTree = decode_data_html_js_1.default;\nvar decode_data_xml_js_1 = __importDefault(require(\"./generated/decode-data-xml.js\"));\nexports.xmlDecodeTree = decode_data_xml_js_1.default;\nvar decode_codepoint_js_1 = __importStar(require(\"./decode_codepoint.js\"));\nexports.decodeCodePoint = decode_codepoint_js_1.default;\nvar decode_codepoint_js_2 = require(\"./decode_codepoint.js\");\nObject.defineProperty(exports, \"replaceCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });\nObject.defineProperty(exports, \"fromCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n    CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n    CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n    CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nvar TO_LOWER_BIT = 32;\nvar BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));\nfunction isNumber(code) {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));\n}\nfunction isAsciiAlphaNumeric(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code));\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n    EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n    EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n    EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nvar DecodingMode;\n(function (DecodingMode) {\n    /** Entities in text nodes that can end with any character. */\n    DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n    /** Only allow entities terminated with a semicolon. */\n    DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n    /** Entities in attributes have limitations on ending characters. */\n    DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nvar EntityDecoder = /** @class */ (function () {\n    function EntityDecoder(\n    /** The tree used to decode entities. */\n    decodeTree, \n    /**\n     * The function that is called when a codepoint is decoded.\n     *\n     * For multi-byte named entities, this will be called multiple times,\n     * with the second codepoint, and the same `consumed` value.\n     *\n     * @param codepoint The decoded codepoint.\n     * @param consumed The number of bytes consumed by the decoder.\n     */\n    emitCodePoint, \n    /** An object that is used to produce errors. */\n    errors) {\n        this.decodeTree = decodeTree;\n        this.emitCodePoint = emitCodePoint;\n        this.errors = errors;\n        /** The current state of the decoder. */\n        this.state = EntityDecoderState.EntityStart;\n        /** Characters that were consumed while parsing an entity. */\n        this.consumed = 1;\n        /**\n         * The result of the entity.\n         *\n         * Either the result index of a numeric entity, or the codepoint of a\n         * numeric entity.\n         */\n        this.result = 0;\n        /** The current index in the decode tree. */\n        this.treeIndex = 0;\n        /** The number of characters that were consumed in excess. */\n        this.excess = 1;\n        /** The mode in which the decoder is operating. */\n        this.decodeMode = DecodingMode.Strict;\n    }\n    /** Resets the instance to make it reusable. */\n    EntityDecoder.prototype.startEntity = function (decodeMode) {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n    };\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param string The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.write = function (str, offset) {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (str.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(str, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(str, offset);\n            }\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(str, offset);\n            }\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(str, offset);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(str, offset);\n            }\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(str, offset);\n            }\n        }\n    };\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericStart = function (str, offset) {\n        if (offset >= str.length) {\n            return -1;\n        }\n        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(str, offset + 1);\n        }\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(str, offset);\n    };\n    EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {\n        if (start !== end) {\n            var digitCount = end - start;\n            this.result =\n                this.result * Math.pow(base, digitCount) +\n                    parseInt(str.substr(start, digitCount), base);\n            this.consumed += digitCount;\n        }\n    };\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericHex = function (str, offset) {\n        var startIdx = offset;\n        while (offset < str.length) {\n            var char = str.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 16);\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return -1;\n    };\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {\n        var startIdx = offset;\n        while (offset < str.length) {\n            var char = str.charCodeAt(offset);\n            if (isNumber(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 10);\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return -1;\n    };\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {\n        var _a;\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n            return 0;\n        }\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        }\n        else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n        return this.consumed;\n    };\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNamedEntity = function (str, offset) {\n        var decodeTree = this.decodeTree;\n        var current = decodeTree[this.treeIndex];\n        // The mask is the number of bytes of the value, including the current byte.\n        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n        for (; offset < str.length; offset++, this.excess++) {\n            var char = str.charCodeAt(offset);\n            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n                }\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {\n        var _a;\n        var _b = this, result = _b.result, decodeTree = _b.decodeTree;\n        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n        return this.consumed;\n    };\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {\n        var decodeTree = this.decodeTree;\n        this.emitCodePoint(valueLength === 1\n            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH\n            : decodeTree[result + 1], consumed);\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n        return consumed;\n    };\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.end = function () {\n        var _a;\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    };\n    return EntityDecoder;\n}());\nexports.EntityDecoder = EntityDecoder;\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n    var ret = \"\";\n    var decoder = new EntityDecoder(decodeTree, function (str) { return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str)); });\n    return function decodeWithTrie(str, decodeMode) {\n        var lastIndex = 0;\n        var offset = 0;\n        while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n            ret += str.slice(lastIndex, offset);\n            decoder.startEntity(decodeMode);\n            var len = decoder.write(str, \n            // Skip the \"&\"\n            offset + 1);\n            if (len < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n            lastIndex = offset + len;\n            // If `len` is 0, skip the current `&` and continue.\n            offset = len === 0 ? lastIndex + 1 : lastIndex;\n        }\n        var result = ret + str.slice(lastIndex);\n        // Make sure we don't keep a reference to the final string.\n        ret = \"\";\n        return result;\n    };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        var value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    var lo = nodeIdx;\n    var hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        var mid = (lo + hi) >>> 1;\n        var midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nexports.determineBranch = determineBranch;\nvar htmlDecoder = getDecoder(decode_data_html_js_1.default);\nvar xmlDecoder = getDecoder(decode_data_xml_js_1.default);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nfunction decodeHTML(str, mode) {\n    if (mode === void 0) { mode = DecodingMode.Legacy; }\n    return htmlDecoder(str, mode);\n}\nexports.decodeHTML = decodeHTML;\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLAttribute(str) {\n    return htmlDecoder(str, DecodingMode.Attribute);\n}\nexports.decodeHTMLAttribute = decodeHTMLAttribute;\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLStrict(str) {\n    return htmlDecoder(str, DecodingMode.Strict);\n}\nexports.decodeHTMLStrict = decodeHTMLStrict;\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeXML(str) {\n    return xmlDecoder(str, DecodingMode.Strict);\n}\nexports.decodeXML = decodeXML;\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"script"}