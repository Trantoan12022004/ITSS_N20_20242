{"ast":null,"code":"/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\nimport Ruler from './ruler.mjs';\nimport StateInline from './rules_inline/state_inline.mjs';\nimport r_text from './rules_inline/text.mjs';\nimport r_linkify from './rules_inline/linkify.mjs';\nimport r_newline from './rules_inline/newline.mjs';\nimport r_escape from './rules_inline/escape.mjs';\nimport r_backticks from './rules_inline/backticks.mjs';\nimport r_strikethrough from './rules_inline/strikethrough.mjs';\nimport r_emphasis from './rules_inline/emphasis.mjs';\nimport r_link from './rules_inline/link.mjs';\nimport r_image from './rules_inline/image.mjs';\nimport r_autolink from './rules_inline/autolink.mjs';\nimport r_html_inline from './rules_inline/html_inline.mjs';\nimport r_entity from './rules_inline/entity.mjs';\nimport r_balance_pairs from './rules_inline/balance_pairs.mjs';\nimport r_fragments_join from './rules_inline/fragments_join.mjs'; // Parser rules\n\nconst _rules = [['text', r_text], ['linkify', r_linkify], ['newline', r_newline], ['escape', r_escape], ['backticks', r_backticks], ['strikethrough', r_strikethrough.tokenize], ['emphasis', r_emphasis.tokenize], ['link', r_link], ['image', r_image], ['autolink', r_autolink], ['html_inline', r_html_inline], ['entity', r_entity]]; // `rule2` ruleset was created specifically for emphasis/strikethrough\n// post-processing and may be changed in the future.\n//\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\n//\n\nconst _rules2 = [['balance_pairs', r_balance_pairs], ['strikethrough', r_strikethrough.postProcess], ['emphasis', r_emphasis.postProcess], // rules for pairs separate '**' into its own text tokens, which may be left unused,\n// rule below merges unused segments back with the rest of the text\n['fragments_join', r_fragments_join]];\n/**\n * new ParserInline()\n **/\n\nfunction ParserInline() {\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n\n\n  this.ruler2 = new Ruler();\n\n  for (let i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n} // Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\n\n\nParserInline.prototype.skipToken = function (state) {\n  const pos = state.pos;\n  const rules = this.ruler.getRules('');\n  const len = rules.length;\n  const maxNesting = state.md.options.maxNesting;\n  const cache = state.cache;\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  let ok = false;\n\n  if (state.level < maxNesting) {\n    for (let i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) {\n        if (pos >= state.pos) {\n          throw new Error(\"inline rule didn't increment state.pos\");\n        }\n\n        break;\n      }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) {\n    state.pos++;\n  }\n\n  cache[pos] = state.pos;\n}; // Generate tokens for input range\n//\n\n\nParserInline.prototype.tokenize = function (state) {\n  const rules = this.ruler.getRules('');\n  const len = rules.length;\n  const end = state.posMax;\n  const maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    const prevPos = state.pos;\n    let ok = false;\n\n    if (state.level < maxNesting) {\n      for (let i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n\n        if (ok) {\n          if (prevPos >= state.pos) {\n            throw new Error(\"inline rule didn't increment state.pos\");\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\n\n\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  const state = new this.State(str, md, env, outTokens);\n  this.tokenize(state);\n  const rules = this.ruler2.getRules('');\n  const len = rules.length;\n\n  for (let i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\nParserInline.prototype.State = StateInline;\nexport default ParserInline;","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/parser_inline.mjs"],"names":["Ruler","StateInline","r_text","r_linkify","r_newline","r_escape","r_backticks","r_strikethrough","r_emphasis","r_link","r_image","r_autolink","r_html_inline","r_entity","r_balance_pairs","r_fragments_join","_rules","tokenize","_rules2","postProcess","ParserInline","ruler","i","length","push","ruler2","prototype","skipToken","state","pos","rules","getRules","len","maxNesting","md","options","cache","ok","level","Error","posMax","end","prevPos","pending","src","pushPending","parse","str","env","outTokens","State"],"mappings":"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","sourcesContent":["/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n\nimport Ruler from './ruler.mjs'\nimport StateInline from './rules_inline/state_inline.mjs'\n\nimport r_text from './rules_inline/text.mjs'\nimport r_linkify from './rules_inline/linkify.mjs'\nimport r_newline from './rules_inline/newline.mjs'\nimport r_escape from './rules_inline/escape.mjs'\nimport r_backticks from './rules_inline/backticks.mjs'\nimport r_strikethrough from './rules_inline/strikethrough.mjs'\nimport r_emphasis from './rules_inline/emphasis.mjs'\nimport r_link from './rules_inline/link.mjs'\nimport r_image from './rules_inline/image.mjs'\nimport r_autolink from './rules_inline/autolink.mjs'\nimport r_html_inline from './rules_inline/html_inline.mjs'\nimport r_entity from './rules_inline/entity.mjs'\n\nimport r_balance_pairs from './rules_inline/balance_pairs.mjs'\nimport r_fragments_join from './rules_inline/fragments_join.mjs'\n\n// Parser rules\n\nconst _rules = [\n  ['text',            r_text],\n  ['linkify',         r_linkify],\n  ['newline',         r_newline],\n  ['escape',          r_escape],\n  ['backticks',       r_backticks],\n  ['strikethrough',   r_strikethrough.tokenize],\n  ['emphasis',        r_emphasis.tokenize],\n  ['link',            r_link],\n  ['image',           r_image],\n  ['autolink',        r_autolink],\n  ['html_inline',     r_html_inline],\n  ['entity',          r_entity]\n]\n\n// `rule2` ruleset was created specifically for emphasis/strikethrough\n// post-processing and may be changed in the future.\n//\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\n//\nconst _rules2 = [\n  ['balance_pairs',   r_balance_pairs],\n  ['strikethrough',   r_strikethrough.postProcess],\n  ['emphasis',        r_emphasis.postProcess],\n  // rules for pairs separate '**' into its own text tokens, which may be left unused,\n  // rule below merges unused segments back with the rest of the text\n  ['fragments_join',  r_fragments_join]\n]\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline () {\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1])\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler()\n\n  for (let i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1])\n  }\n}\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  const pos = state.pos\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  const cache = state.cache\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos]\n    return\n  }\n\n  let ok = false\n\n  if (state.level < maxNesting) {\n    for (let i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++\n      ok = rules[i](state, true)\n      state.level--\n\n      if (ok) {\n        if (pos >= state.pos) { throw new Error(\"inline rule didn't increment state.pos\") }\n        break\n      }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax\n  }\n\n  if (!ok) { state.pos++ }\n  cache[pos] = state.pos\n}\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const end = state.posMax\n  const maxNesting = state.md.options.maxNesting\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    const prevPos = state.pos\n    let ok = false\n\n    if (state.level < maxNesting) {\n      for (let i = 0; i < len; i++) {\n        ok = rules[i](state, false)\n        if (ok) {\n          if (prevPos >= state.pos) { throw new Error(\"inline rule didn't increment state.pos\") }\n          break\n        }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break }\n      continue\n    }\n\n    state.pending += state.src[state.pos++]\n  }\n\n  if (state.pending) {\n    state.pushPending()\n  }\n}\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  const state = new this.State(str, md, env, outTokens)\n\n  this.tokenize(state)\n\n  const rules = this.ruler2.getRules('')\n  const len = rules.length\n\n  for (let i = 0; i < len; i++) {\n    rules[i](state)\n  }\n}\n\nParserInline.prototype.State = StateInline\n\nexport default ParserInline\n"]},"metadata":{},"sourceType":"module"}