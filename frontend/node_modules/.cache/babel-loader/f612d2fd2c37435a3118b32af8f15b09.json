{"ast":null,"code":"// lheading (---, ===)\nexport default function lheading(state, startLine, endLine\n/*, silent */\n) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph'); // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  const oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n  // jump line-by-line until empty one or EOF\n\n  let level = 0;\n  let marker;\n  let nextLine = startLine + 1;\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    } //\n    // Check for underline in setext header\n    //\n\n\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      const max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D\n        /* - */\n        || marker === 0x3D\n        /* = */\n        ) {\n            pos = state.skipChars(pos, marker);\n            pos = state.skipSpaces(pos);\n\n            if (pos >= max) {\n              level = marker === 0x3D\n              /* = */\n              ? 1 : 2;\n              break;\n            }\n          }\n      }\n    } // quirk for blockquotes, this line should already be checked by that rule\n\n\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    } // Some tags can terminate paragraph without empty line.\n\n\n    let terminate = false;\n\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine + 1;\n  const token_o = state.push('heading_open', 'h' + String(level), 1);\n  token_o.markup = String.fromCharCode(marker);\n  token_o.map = [startLine, state.line];\n  const token_i = state.push('inline', '', 0);\n  token_i.content = content;\n  token_i.map = [startLine, state.line - 1];\n  token_i.children = [];\n  const token_c = state.push('heading_close', 'h' + String(level), -1);\n  token_c.markup = String.fromCharCode(marker);\n  state.parentType = oldParentType;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/lheading.mjs"],"names":["lheading","state","startLine","endLine","terminatorRules","md","block","ruler","getRules","sCount","blkIndent","oldParentType","parentType","level","marker","nextLine","isEmpty","pos","bMarks","tShift","max","eMarks","src","charCodeAt","skipChars","skipSpaces","terminate","i","l","length","content","getLines","trim","line","token_o","push","String","markup","fromCharCode","map","token_i","children","token_c"],"mappings":"AAAA;AAEA,eAAe,SAASA,QAAT,CAAmBC,KAAnB,EAA0BC,SAA1B,EAAqCC;AAAO;AAA5C,EAA2D;AACxE,QAAMC,eAAe,GAAGH,KAAK,CAACI,EAAN,CAASC,KAAT,CAAeC,KAAf,CAAqBC,QAArB,CAA8B,WAA9B,CAAxB,CADwE,CAGxE;;AACA,MAAIP,KAAK,CAACQ,MAAN,CAAaP,SAAb,IAA0BD,KAAK,CAACS,SAAhC,IAA6C,CAAjD,EAAoD;AAAE,WAAO,KAAP;AAAc;;AAEpE,QAAMC,aAAa,GAAGV,KAAK,CAACW,UAA5B;AACAX,EAAAA,KAAK,CAACW,UAAN,GAAmB,WAAnB,CAPwE,CAOzC;AAE/B;;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,MAAJ;AACA,MAAIC,QAAQ,GAAGb,SAAS,GAAG,CAA3B;;AAEA,SAAOa,QAAQ,GAAGZ,OAAX,IAAsB,CAACF,KAAK,CAACe,OAAN,CAAcD,QAAd,CAA9B,EAAuDA,QAAQ,EAA/D,EAAmE;AACjE;AACA;AACA,QAAId,KAAK,CAACQ,MAAN,CAAaM,QAAb,IAAyBd,KAAK,CAACS,SAA/B,GAA2C,CAA/C,EAAkD;AAAE;AAAU,KAHG,CAKjE;AACA;AACA;;;AACA,QAAIT,KAAK,CAACQ,MAAN,CAAaM,QAAb,KAA0Bd,KAAK,CAACS,SAApC,EAA+C;AAC7C,UAAIO,GAAG,GAAGhB,KAAK,CAACiB,MAAN,CAAaH,QAAb,IAAyBd,KAAK,CAACkB,MAAN,CAAaJ,QAAb,CAAnC;AACA,YAAMK,GAAG,GAAGnB,KAAK,CAACoB,MAAN,CAAaN,QAAb,CAAZ;;AAEA,UAAIE,GAAG,GAAGG,GAAV,EAAe;AACbN,QAAAA,MAAM,GAAGb,KAAK,CAACqB,GAAN,CAAUC,UAAV,CAAqBN,GAArB,CAAT;;AAEA,YAAIH,MAAM,KAAK;AAAI;AAAf,WAA0BA,MAAM,KAAK;AAAI;AAA7C,UAAsD;AACpDG,YAAAA,GAAG,GAAGhB,KAAK,CAACuB,SAAN,CAAgBP,GAAhB,EAAqBH,MAArB,CAAN;AACAG,YAAAA,GAAG,GAAGhB,KAAK,CAACwB,UAAN,CAAiBR,GAAjB,CAAN;;AAEA,gBAAIA,GAAG,IAAIG,GAAX,EAAgB;AACdP,cAAAA,KAAK,GAAIC,MAAM,KAAK;AAAI;AAAf,gBAAyB,CAAzB,GAA6B,CAAtC;AACA;AACD;AACF;AACF;AACF,KAzBgE,CA2BjE;;;AACA,QAAIb,KAAK,CAACQ,MAAN,CAAaM,QAAb,IAAyB,CAA7B,EAAgC;AAAE;AAAU,KA5BqB,CA8BjE;;;AACA,QAAIW,SAAS,GAAG,KAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGxB,eAAe,CAACyB,MAApC,EAA4CF,CAAC,GAAGC,CAAhD,EAAmDD,CAAC,EAApD,EAAwD;AACtD,UAAIvB,eAAe,CAACuB,CAAD,CAAf,CAAmB1B,KAAnB,EAA0Bc,QAA1B,EAAoCZ,OAApC,EAA6C,IAA7C,CAAJ,EAAwD;AACtDuB,QAAAA,SAAS,GAAG,IAAZ;AACA;AACD;AACF;;AACD,QAAIA,SAAJ,EAAe;AAAE;AAAO;AACzB;;AAED,MAAI,CAACb,KAAL,EAAY;AACV;AACA,WAAO,KAAP;AACD;;AAED,QAAMiB,OAAO,GAAG7B,KAAK,CAAC8B,QAAN,CAAe7B,SAAf,EAA0Ba,QAA1B,EAAoCd,KAAK,CAACS,SAA1C,EAAqD,KAArD,EAA4DsB,IAA5D,EAAhB;AAEA/B,EAAAA,KAAK,CAACgC,IAAN,GAAalB,QAAQ,GAAG,CAAxB;AAEA,QAAMmB,OAAO,GAAMjC,KAAK,CAACkC,IAAN,CAAW,cAAX,EAA2B,MAAMC,MAAM,CAACvB,KAAD,CAAvC,EAAgD,CAAhD,CAAnB;AACAqB,EAAAA,OAAO,CAACG,MAAR,GAAmBD,MAAM,CAACE,YAAP,CAAoBxB,MAApB,CAAnB;AACAoB,EAAAA,OAAO,CAACK,GAAR,GAAmB,CAACrC,SAAD,EAAYD,KAAK,CAACgC,IAAlB,CAAnB;AAEA,QAAMO,OAAO,GAAMvC,KAAK,CAACkC,IAAN,CAAW,QAAX,EAAqB,EAArB,EAAyB,CAAzB,CAAnB;AACAK,EAAAA,OAAO,CAACV,OAAR,GAAmBA,OAAnB;AACAU,EAAAA,OAAO,CAACD,GAAR,GAAmB,CAACrC,SAAD,EAAYD,KAAK,CAACgC,IAAN,GAAa,CAAzB,CAAnB;AACAO,EAAAA,OAAO,CAACC,QAAR,GAAmB,EAAnB;AAEA,QAAMC,OAAO,GAAMzC,KAAK,CAACkC,IAAN,CAAW,eAAX,EAA4B,MAAMC,MAAM,CAACvB,KAAD,CAAxC,EAAiD,CAAC,CAAlD,CAAnB;AACA6B,EAAAA,OAAO,CAACL,MAAR,GAAmBD,MAAM,CAACE,YAAP,CAAoBxB,MAApB,CAAnB;AAEAb,EAAAA,KAAK,CAACW,UAAN,GAAmBD,aAAnB;AAEA,SAAO,IAAP;AACD","sourcesContent":["// lheading (---, ===)\n\nexport default function lheading (state, startLine, endLine/*, silent */) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph')\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  const oldParentType = state.parentType\n  state.parentType = 'paragraph' // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  let level = 0\n  let marker\n  let nextLine = startLine + 1\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      const max = state.eMarks[nextLine]\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos)\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker)\n          pos = state.skipSpaces(pos)\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2)\n            break\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n\n  state.line = nextLine + 1\n\n  const token_o    = state.push('heading_open', 'h' + String(level), 1)\n  token_o.markup   = String.fromCharCode(marker)\n  token_o.map      = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = content\n  token_i.map      = [startLine, state.line - 1]\n  token_i.children = []\n\n  const token_c    = state.push('heading_close', 'h' + String(level), -1)\n  token_c.markup   = String.fromCharCode(marker)\n\n  state.parentType = oldParentType\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}