{"ast":null,"code":"// Lists\nimport { isSpace } from '../common/utils.mjs'; // Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\nfunction skipBulletListMarker(state, startLine) {\n  const max = state.eMarks[startLine];\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  const marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const max = state.eMarks[startLine];\n  let pos = start; // List marker should have at least 2 chars (digit + dot)\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  let ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        // List marker should have no more than 9 digits\n        // (prevents integer overflow in browsers)\n        if (pos - start >= 10) {\n          return -1;\n        }\n\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  const level = state.level + 2;\n\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\nexport default function list(state, startLine, endLine, silent) {\n  let max, pos, start, token;\n  let nextLine = startLine;\n  let tight = true; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[nextLine] - state.blkIndent >= 4) {\n    return false;\n  } // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n\n\n  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  let isTerminatingParagraph = false; // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  } // Detect list type and position after marker\n\n\n  let isOrdered;\n  let markerValue;\n  let posAfterMarker;\n\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[nextLine] + state.tShift[nextLine];\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1)); // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  } // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n\n\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;\n  } // For validation mode we can terminate immediately\n\n\n  if (silent) {\n    return true;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // Start list\n\n  const listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token = state.push('ordered_list_open', 'ol', 1);\n\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]];\n    }\n  } else {\n    token = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  const listLines = [nextLine, 0];\n  token.map = listLines;\n  token.markup = String.fromCharCode(markerCharCode); //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false;\n  const terminatorRules = state.md.block.ruler.getRules('list');\n  const oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);\n    let offset = initial;\n\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    const contentStart = pos;\n    let indentAfterMarker;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    const indent = initial + indentAfterMarker; // Run subparser & write tokens\n\n    token = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    const itemLines = [nextLine, 0];\n    token.map = itemLines;\n\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1);\n    } // change current state, then restore it after parser subcall\n\n\n    const oldTight = state.tight;\n    const oldTShift = state.tShift[nextLine];\n    const oldSCount = state.sCount[nextLine]; //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n\n    const oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];\n    state.sCount[nextLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true);\n    } // If any of list item is tight, mark list as tight\n\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[nextLine] = oldTShift;\n    state.sCount[nextLine] = oldSCount;\n    state.tight = oldTight;\n    token = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n    nextLine = state.line;\n    itemLines[1] = nextLine;\n\n    if (nextLine >= endLine) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    } // if it's indented more than 3 spaces, it should be a code block\n\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      break;\n    } // fail if terminating block found\n\n\n    let terminate = false;\n\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finalize list\n\n\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n\n  token.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/list.mjs"],"names":["isSpace","skipBulletListMarker","state","startLine","max","eMarks","pos","bMarks","tShift","marker","src","charCodeAt","ch","skipOrderedListMarker","start","markTightParagraphs","idx","level","i","l","tokens","length","type","hidden","list","endLine","silent","token","nextLine","tight","sCount","blkIndent","listIndent","isTerminatingParagraph","parentType","isOrdered","markerValue","posAfterMarker","Number","slice","skipSpaces","markerCharCode","listTokIdx","push","attrs","listLines","map","markup","String","fromCharCode","prevEmptyEnd","terminatorRules","md","block","ruler","getRules","oldParentType","initial","offset","bsCount","contentStart","indentAfterMarker","indent","itemLines","info","oldTight","oldTShift","oldSCount","oldListIndent","isEmpty","line","Math","min","tokenize","terminate"],"mappings":"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","sourcesContent":["// Lists\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker (state, startLine) {\n  const max = state.eMarks[startLine]\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n\n  const marker = state.src.charCodeAt(pos++)\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1\n  }\n\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1\n    }\n  }\n\n  return pos\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker (state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine]\n  const max = state.eMarks[startLine]\n  let pos = start\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1 }\n\n  let ch = state.src.charCodeAt(pos++)\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1 }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1 }\n\n    ch = state.src.charCodeAt(pos++)\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1 }\n\n      continue\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break\n    }\n\n    return -1\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1\n    }\n  }\n  return pos\n}\n\nfunction markTightParagraphs (state, idx) {\n  const level = state.level + 2\n\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true\n      state.tokens[i].hidden = true\n      i += 2\n    }\n  }\n}\n\nexport default function list (state, startLine, endLine, silent) {\n  let max, pos, start, token\n  let nextLine = startLine\n  let tight = true\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[nextLine] - state.listIndent >= 4 &&\n      state.sCount[nextLine] < state.blkIndent) {\n    return false\n  }\n\n  let isTerminatingParagraph = false\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true\n    }\n  }\n\n  // Detect list type and position after marker\n  let isOrdered\n  let markerValue\n  let posAfterMarker\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true\n    start = state.bMarks[nextLine] + state.tShift[nextLine]\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1))\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false\n  } else {\n    return false\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false\n  }\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true }\n\n  // We should terminate list on style change. Remember first one to compare.\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1)\n\n  // Start list\n  const listTokIdx = state.tokens.length\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1)\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]]\n    }\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1)\n  }\n\n  const listLines = [nextLine, 0]\n  token.map    = listLines\n  token.markup = String.fromCharCode(markerCharCode)\n\n  //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false\n  const terminatorRules = state.md.block.ruler.getRules('list')\n\n  const oldParentType = state.parentType\n  state.parentType = 'list'\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker\n    max = state.eMarks[nextLine]\n\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine])\n    let offset = initial\n\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos)\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4\n      } else if (ch === 0x20) {\n        offset++\n      } else {\n        break\n      }\n\n      pos++\n    }\n\n    const contentStart = pos\n    let indentAfterMarker\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1\n    } else {\n      indentAfterMarker = offset - initial\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1 }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    const indent = initial + indentAfterMarker\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1)\n    token.markup = String.fromCharCode(markerCharCode)\n    const itemLines = [nextLine, 0]\n    token.map    = itemLines\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1)\n    }\n\n    // change current state, then restore it after parser subcall\n    const oldTight = state.tight\n    const oldTShift = state.tShift[nextLine]\n    const oldSCount = state.sCount[nextLine]\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    const oldListIndent = state.listIndent\n    state.listIndent = state.blkIndent\n    state.blkIndent = indent\n\n    state.tight = true\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine]\n    state.sCount[nextLine] = offset\n\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine)\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true)\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - nextLine) > 1 && state.isEmpty(state.line - 1)\n\n    state.blkIndent = state.listIndent\n    state.listIndent = oldListIndent\n    state.tShift[nextLine] = oldTShift\n    state.sCount[nextLine] = oldSCount\n    state.tight = oldTight\n\n    token        = state.push('list_item_close', 'li', -1)\n    token.markup = String.fromCharCode(markerCharCode)\n\n    nextLine = state.line\n    itemLines[1] = nextLine\n\n    if (nextLine >= endLine) { break }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n\n    // fail if terminating block found\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1)\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1)\n  }\n  token.markup = String.fromCharCode(markerCharCode)\n\n  listLines[1] = nextLine\n  state.line = nextLine\n\n  state.parentType = oldParentType\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx)\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}