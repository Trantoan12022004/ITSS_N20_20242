{"ast":null,"code":"// Block quotes\nimport { isSpace } from '../common/utils.mjs';\nexport default function blockquote(state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n  const oldLineMax = state.lineMax; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos) !== 0x3E\n  /* > */\n  ) {\n      return false;\n    } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  }\n\n  const oldBMarks = [];\n  const oldBSCount = [];\n  const oldSCount = [];\n  const oldTShift = [];\n  const terminatorRules = state.md.block.ruler.getRules('blockquote');\n  const oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  let lastLineEmpty = false;\n  let nextLine; // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    const isOutdented = state.sCount[nextLine] < state.blkIndent;\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    && !isOutdented) {\n      // This line is inside the blockquote.\n      // set offset past spaces and \">\"\n      let initial = state.sCount[nextLine] + 1;\n      let spaceAfterMarker;\n      let adjustTab; // skip one optional space after '>'\n\n      if (state.src.charCodeAt(pos) === 0x20\n      /* space */\n      ) {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charCodeAt(pos) === 0x09\n      /* tab */\n      ) {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n        spaceAfterMarker = false;\n      }\n\n      let offset = initial;\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    let terminate = false;\n\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]); // A negative indentation means that this is a paragraph continuation\n    //\n\n    state.sCount[nextLine] = -1;\n  }\n\n  const oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  const token_o = state.push('blockquote_open', 'blockquote', 1);\n  token_o.markup = '>';\n  const lines = [startLine, 0];\n  token_o.map = lines;\n  state.md.block.tokenize(state, startLine, nextLine);\n  const token_c = state.push('blockquote_close', 'blockquote', -1);\n  token_c.markup = '>';\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (let i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/blockquote.mjs"],"names":["isSpace","blockquote","state","startLine","endLine","silent","pos","bMarks","tShift","max","eMarks","oldLineMax","lineMax","sCount","blkIndent","src","charCodeAt","oldBMarks","oldBSCount","oldSCount","oldTShift","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","lastLineEmpty","nextLine","isOutdented","initial","spaceAfterMarker","adjustTab","bsCount","offset","push","ch","terminate","i","l","length","oldIndent","token_o","markup","lines","map","tokenize","token_c","line"],"mappings":"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","sourcesContent":["// Block quotes\n\nimport { isSpace } from '../common/utils.mjs'\n\nexport default function blockquote (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  const oldLineMax = state.lineMax\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos) !== 0x3E/* > */) { return false }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true }\n\n  const oldBMarks  = []\n  const oldBSCount = []\n  const oldSCount  = []\n  const oldTShift  = []\n\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const oldParentType = state.parentType\n  state.parentType = 'blockquote'\n  let lastLineEmpty = false\n  let nextLine\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    const isOutdented = state.sCount[nextLine] < state.blkIndent\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      let initial = state.sCount[nextLine] + 1\n      let spaceAfterMarker\n      let adjustTab\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++\n        initial++\n        adjustTab = false\n        spaceAfterMarker = true\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true\n\n        if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++\n          initial++\n          adjustTab = false\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true\n        }\n      } else {\n        spaceAfterMarker = false\n      }\n\n      let offset = initial\n      oldBMarks.push(state.bMarks[nextLine])\n      state.bMarks[nextLine] = pos\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos)\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4\n          } else {\n            offset++\n          }\n        } else {\n          break\n        }\n\n        pos++\n      }\n\n      lastLineEmpty = pos >= max\n\n      oldBSCount.push(state.bsCount[nextLine])\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)\n\n      oldSCount.push(state.sCount[nextLine])\n      state.sCount[nextLine] = offset - initial\n\n      oldTShift.push(state.tShift[nextLine])\n      state.tShift[nextLine] = pos - state.bMarks[nextLine]\n      continue\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break }\n\n    // Case 3: another tag found.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine])\n        oldBSCount.push(state.bsCount[nextLine])\n        oldTShift.push(state.tShift[nextLine])\n        oldSCount.push(state.sCount[nextLine])\n        state.sCount[nextLine] -= state.blkIndent\n      }\n\n      break\n    }\n\n    oldBMarks.push(state.bMarks[nextLine])\n    oldBSCount.push(state.bsCount[nextLine])\n    oldTShift.push(state.tShift[nextLine])\n    oldSCount.push(state.sCount[nextLine])\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1\n  }\n\n  const oldIndent = state.blkIndent\n  state.blkIndent = 0\n\n  const token_o  = state.push('blockquote_open', 'blockquote', 1)\n  token_o.markup = '>'\n  const lines = [startLine, 0]\n  token_o.map    = lines\n\n  state.md.block.tokenize(state, startLine, nextLine)\n\n  const token_c  = state.push('blockquote_close', 'blockquote', -1)\n  token_c.markup = '>'\n\n  state.lineMax = oldLineMax\n  state.parentType = oldParentType\n  lines[1] = state.line\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (let i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i]\n    state.tShift[i + startLine] = oldTShift[i]\n    state.sCount[i + startLine] = oldSCount[i]\n    state.bsCount[i + startLine] = oldBSCount[i]\n  }\n  state.blkIndent = oldIndent\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}