{"ast":null,"code":"// Parse backticks\nexport default function backtick(state, silent) {\n  let pos = state.pos;\n  const ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60\n  /* ` */\n  ) {\n      return false;\n    }\n\n  const start = pos;\n  pos++;\n  const max = state.posMax; // scan marker length\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60\n  /* ` */\n  ) {\n    pos++;\n  }\n\n  const marker = state.src.slice(start, pos);\n  const openerLength = marker.length;\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  }\n\n  let matchEnd = pos;\n  let matchStart; // Nothing found in the cache, scan until the end of the line (or until marker is found)\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1; // scan marker length\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60\n    /* ` */\n    ) {\n      matchEnd++;\n    }\n\n    const closerLength = matchEnd - matchStart;\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        const token = state.push('code_inline', 'code', 0);\n        token.markup = marker;\n        token.content = state.src.slice(pos, matchStart).replace(/\\n/g, ' ').replace(/^ (.+) $/, '$1');\n      }\n\n      state.pos = matchEnd;\n      return true;\n    } // Some different length found, put it in cache as upper limit of where closer can be found\n\n\n    state.backticks[closerLength] = matchStart;\n  } // Scanned through the end, didn't find anything\n\n\n  state.backticksScanned = true;\n  if (!silent) state.pending += marker;\n  state.pos += openerLength;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_inline/backticks.mjs"],"names":["backtick","state","silent","pos","ch","src","charCodeAt","start","max","posMax","marker","slice","openerLength","length","backticksScanned","backticks","pending","matchEnd","matchStart","indexOf","closerLength","token","push","markup","content","replace"],"mappings":"AAAA;AAEA,eAAe,SAASA,QAAT,CAAmBC,KAAnB,EAA0BC,MAA1B,EAAkC;AAC/C,MAAIC,GAAG,GAAGF,KAAK,CAACE,GAAhB;AACA,QAAMC,EAAE,GAAGH,KAAK,CAACI,GAAN,CAAUC,UAAV,CAAqBH,GAArB,CAAX;;AAEA,MAAIC,EAAE,KAAK;AAAI;AAAf,IAAwB;AAAE,aAAO,KAAP;AAAc;;AAExC,QAAMG,KAAK,GAAGJ,GAAd;AACAA,EAAAA,GAAG;AACH,QAAMK,GAAG,GAAGP,KAAK,CAACQ,MAAlB,CAR+C,CAU/C;;AACA,SAAON,GAAG,GAAGK,GAAN,IAAaP,KAAK,CAACI,GAAN,CAAUC,UAAV,CAAqBH,GAArB,MAA8B;AAAI;AAAtD,IAA+D;AAAEA,IAAAA,GAAG;AAAI;;AAExE,QAAMO,MAAM,GAAGT,KAAK,CAACI,GAAN,CAAUM,KAAV,CAAgBJ,KAAhB,EAAuBJ,GAAvB,CAAf;AACA,QAAMS,YAAY,GAAGF,MAAM,CAACG,MAA5B;;AAEA,MAAIZ,KAAK,CAACa,gBAAN,IAA0B,CAACb,KAAK,CAACc,SAAN,CAAgBH,YAAhB,KAAiC,CAAlC,KAAwCL,KAAtE,EAA6E;AAC3E,QAAI,CAACL,MAAL,EAAaD,KAAK,CAACe,OAAN,IAAiBN,MAAjB;AACbT,IAAAA,KAAK,CAACE,GAAN,IAAaS,YAAb;AACA,WAAO,IAAP;AACD;;AAED,MAAIK,QAAQ,GAAGd,GAAf;AACA,MAAIe,UAAJ,CAvB+C,CAyB/C;;AACA,SAAO,CAACA,UAAU,GAAGjB,KAAK,CAACI,GAAN,CAAUc,OAAV,CAAkB,GAAlB,EAAuBF,QAAvB,CAAd,MAAoD,CAAC,CAA5D,EAA+D;AAC7DA,IAAAA,QAAQ,GAAGC,UAAU,GAAG,CAAxB,CAD6D,CAG7D;;AACA,WAAOD,QAAQ,GAAGT,GAAX,IAAkBP,KAAK,CAACI,GAAN,CAAUC,UAAV,CAAqBW,QAArB,MAAmC;AAAI;AAAhE,MAAyE;AAAEA,MAAAA,QAAQ;AAAI;;AAEvF,UAAMG,YAAY,GAAGH,QAAQ,GAAGC,UAAhC;;AAEA,QAAIE,YAAY,KAAKR,YAArB,EAAmC;AACjC;AACA,UAAI,CAACV,MAAL,EAAa;AACX,cAAMmB,KAAK,GAAGpB,KAAK,CAACqB,IAAN,CAAW,aAAX,EAA0B,MAA1B,EAAkC,CAAlC,CAAd;AACAD,QAAAA,KAAK,CAACE,MAAN,GAAeb,MAAf;AACAW,QAAAA,KAAK,CAACG,OAAN,GAAgBvB,KAAK,CAACI,GAAN,CAAUM,KAAV,CAAgBR,GAAhB,EAAqBe,UAArB,EACbO,OADa,CACL,KADK,EACE,GADF,EAEbA,OAFa,CAEL,UAFK,EAEO,IAFP,CAAhB;AAGD;;AACDxB,MAAAA,KAAK,CAACE,GAAN,GAAYc,QAAZ;AACA,aAAO,IAAP;AACD,KAnB4D,CAqB7D;;;AACAhB,IAAAA,KAAK,CAACc,SAAN,CAAgBK,YAAhB,IAAgCF,UAAhC;AACD,GAjD8C,CAmD/C;;;AACAjB,EAAAA,KAAK,CAACa,gBAAN,GAAyB,IAAzB;AAEA,MAAI,CAACZ,MAAL,EAAaD,KAAK,CAACe,OAAN,IAAiBN,MAAjB;AACbT,EAAAA,KAAK,CAACE,GAAN,IAAaS,YAAb;AACA,SAAO,IAAP;AACD","sourcesContent":["// Parse backticks\n\nexport default function backtick (state, silent) {\n  let pos = state.pos\n  const ch = state.src.charCodeAt(pos)\n\n  if (ch !== 0x60/* ` */) { return false }\n\n  const start = pos\n  pos++\n  const max = state.posMax\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++ }\n\n  const marker = state.src.slice(start, pos)\n  const openerLength = marker.length\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker\n    state.pos += openerLength\n    return true\n  }\n\n  let matchEnd = pos\n  let matchStart\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++ }\n\n    const closerLength = matchEnd - matchStart\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        const token = state.push('code_inline', 'code', 0)\n        token.markup = marker\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1')\n      }\n      state.pos = matchEnd\n      return true\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true\n\n  if (!silent) state.pending += marker\n  state.pos += openerLength\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}