{"ast":null,"code":"// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx,\n    openerIdx,\n    closer,\n    opener,\n    minOpenerIdx,\n    newMinOpenerIdx,\n    isOddMatch,\n    lastJump,\n    openersBottom = {},\n    max = delimiters.length;\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1];\n    }\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n    openerIdx = closerIdx - closer.jump - 1;\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker) continue;\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n      if (opener.open && opener.end < 0) {\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? delimiters[openerIdx - 1].jump + 1 : 0;\n          closer.jump = closerIdx - openerIdx + lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.jump = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\nmodule.exports = function link_pairs(state) {\n  var curr,\n    tokens_meta = state.tokens_meta,\n    max = state.tokens_meta.length;\n  processDelimiters(state, state.delimiters);\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};","map":{"version":3,"names":["processDelimiters","state","delimiters","closerIdx","openerIdx","closer","opener","minOpenerIdx","newMinOpenerIdx","isOddMatch","lastJump","openersBottom","max","length","close","hasOwnProperty","marker","jump","open","end","module","exports","link_pairs","curr","tokens_meta"],"sources":["C:/Users/Trant/Documents/Lập Trình Web/CTES WEB/React - Copy/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],"sourcesContent":["// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n\n    openerIdx = closerIdx - closer.jump - 1;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            delimiters[openerIdx - 1].jump + 1 :\n            0;\n\n          closer.jump  = closerIdx - openerIdx + lastJump;\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.jump  = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}