{"ast":null,"code":"// Convert straight quotation marks to typographic ones\n//\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs';\nconst QUOTE_TEST_RE = /['\"]/;\nconst QUOTE_RE = /['\"]/g;\nconst APOSTROPHE = '\\u2019';\n/* ’ */\n\nfunction replaceAt(str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  let j;\n  const stack = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) {\n        break;\n      }\n    }\n\n    stack.length = j + 1;\n\n    if (token.type !== 'text') {\n      continue;\n    }\n\n    let text = token.content;\n    let pos = 0;\n    let max = text.length;\n    /* eslint no-labels:0,block-scoped-var:0 */\n\n    OUTER: while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      const t = QUOTE_RE.exec(text);\n\n      if (!t) {\n        break;\n      }\n\n      let canOpen = true;\n      let canClose = true;\n      pos = t.index + 1;\n      const isSingle = t[0] === \"'\"; // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n\n      let lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      } // Find next character,\n      // default to space if it's the end of the line\n      //\n\n\n      let nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n      const isLastWhiteSpace = isWhiteSpace(lastChar);\n      const isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22\n      /* \" */\n      && t[0] === '\"') {\n        if (lastChar >= 0x30\n        /* 0 */\n        && lastChar <= 0x39\n        /* 9 */\n        ) {\n            // special case: 1\"\" - count first quote as an inch\n            canClose = canOpen = false;\n          }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j];\n\n          if (stack[j].level < thisLevel) {\n            break;\n          }\n\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n            let openQuote;\n            let closeQuote;\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            } // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n\n\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n            pos += closeQuote.length - 1;\n\n            if (item.token === i) {\n              pos += openQuote.length - 1;\n            }\n\n            text = token.content;\n            max = text.length;\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\nexport default function smartquotes(state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) {\n    return;\n  }\n\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_core/smartquotes.mjs"],"names":["isWhiteSpace","isPunctChar","isMdAsciiPunct","QUOTE_TEST_RE","QUOTE_RE","APOSTROPHE","replaceAt","str","index","ch","slice","process_inlines","tokens","state","j","stack","i","length","token","thisLevel","level","type","text","content","pos","max","OUTER","lastIndex","t","exec","canOpen","canClose","isSingle","lastChar","charCodeAt","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","item","single","openQuote","closeQuote","md","options","quotes","push","smartquotes","typographer","blkIdx","test","children"],"mappings":"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","sourcesContent":["// Convert straight quotation marks to typographic ones\n//\n\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nconst QUOTE_TEST_RE = /['\"]/\nconst QUOTE_RE = /['\"]/g\nconst APOSTROPHE = '\\u2019' /* ’ */\n\nfunction replaceAt (str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1)\n}\n\nfunction process_inlines (tokens, state) {\n  let j\n\n  const stack = []\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    const thisLevel = tokens[i].level\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break }\n    }\n    stack.length = j + 1\n\n    if (token.type !== 'text') { continue }\n\n    let text = token.content\n    let pos = 0\n    let max = text.length\n\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos\n      const t = QUOTE_RE.exec(text)\n      if (!t) { break }\n\n      let canOpen = true\n      let canClose = true\n      pos = t.index + 1\n      const isSingle = (t[0] === \"'\")\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      let lastChar = 0x20\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1)\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // lastChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1)\n          break\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      let nextChar = 0x20\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos)\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // nextChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0)\n          break\n        }\n      }\n\n      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n      const isLastWhiteSpace = isWhiteSpace(lastChar)\n      const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n      if (isNextWhiteSpace) {\n        canOpen = false\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar\n        canClose = isNextPunctChar\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE)\n        }\n        continue\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j]\n          if (stack[j].level < thisLevel) { break }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j]\n\n            let openQuote\n            let closeQuote\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2]\n              closeQuote = state.md.options.quotes[3]\n            } else {\n              openQuote = state.md.options.quotes[0]\n              closeQuote = state.md.options.quotes[1]\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote)\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote)\n\n            pos += closeQuote.length - 1\n            if (item.token === i) { pos += openQuote.length - 1 }\n\n            text = token.content\n            max = text.length\n\n            stack.length = j\n            continue OUTER\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        })\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE)\n      }\n    }\n  }\n}\n\nexport default function smartquotes (state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) { return }\n\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}