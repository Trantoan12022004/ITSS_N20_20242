{"ast":null,"code":"// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\nexport default function parseLinkLabel(state, start, disableNested) {\n  let level, found, marker, prevPos;\n  const max = state.posMax;\n  const oldPos = state.pos;\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5D\n    /* ] */\n    ) {\n        level--;\n\n        if (level === 0) {\n          found = true;\n          break;\n        }\n      }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n        if (prevPos === state.pos - 1) {\n          // increase level if we find text `[`, which is not a part of any token\n          level++;\n        } else if (disableNested) {\n          state.pos = oldPos;\n          return -1;\n        }\n      }\n  }\n\n  let labelEnd = -1;\n\n  if (found) {\n    labelEnd = state.pos;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  return labelEnd;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/helpers/parse_link_label.mjs"],"names":["parseLinkLabel","state","start","disableNested","level","found","marker","prevPos","max","posMax","oldPos","pos","src","charCodeAt","md","inline","skipToken","labelEnd"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,eAAe,SAASA,cAAT,CAAyBC,KAAzB,EAAgCC,KAAhC,EAAuCC,aAAvC,EAAsD;AACnE,MAAIC,KAAJ,EAAWC,KAAX,EAAkBC,MAAlB,EAA0BC,OAA1B;AAEA,QAAMC,GAAG,GAAGP,KAAK,CAACQ,MAAlB;AACA,QAAMC,MAAM,GAAGT,KAAK,CAACU,GAArB;AAEAV,EAAAA,KAAK,CAACU,GAAN,GAAYT,KAAK,GAAG,CAApB;AACAE,EAAAA,KAAK,GAAG,CAAR;;AAEA,SAAOH,KAAK,CAACU,GAAN,GAAYH,GAAnB,EAAwB;AACtBF,IAAAA,MAAM,GAAGL,KAAK,CAACW,GAAN,CAAUC,UAAV,CAAqBZ,KAAK,CAACU,GAA3B,CAAT;;AACA,QAAIL,MAAM,KAAK;AAAK;AAApB,MAA6B;AAC3BF,QAAAA,KAAK;;AACL,YAAIA,KAAK,KAAK,CAAd,EAAiB;AACfC,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;AACF;;AAEDE,IAAAA,OAAO,GAAGN,KAAK,CAACU,GAAhB;AACAV,IAAAA,KAAK,CAACa,EAAN,CAASC,MAAT,CAAgBC,SAAhB,CAA0Bf,KAA1B;;AACA,QAAIK,MAAM,KAAK;AAAK;AAApB,MAA6B;AAC3B,YAAIC,OAAO,KAAKN,KAAK,CAACU,GAAN,GAAY,CAA5B,EAA+B;AAC7B;AACAP,UAAAA,KAAK;AACN,SAHD,MAGO,IAAID,aAAJ,EAAmB;AACxBF,UAAAA,KAAK,CAACU,GAAN,GAAYD,MAAZ;AACA,iBAAO,CAAC,CAAR;AACD;AACF;AACF;;AAED,MAAIO,QAAQ,GAAG,CAAC,CAAhB;;AAEA,MAAIZ,KAAJ,EAAW;AACTY,IAAAA,QAAQ,GAAGhB,KAAK,CAACU,GAAjB;AACD,GApCkE,CAsCnE;;;AACAV,EAAAA,KAAK,CAACU,GAAN,GAAYD,MAAZ;AAEA,SAAOO,QAAP;AACD","sourcesContent":["// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\nexport default function parseLinkLabel (state, start, disableNested) {\n  let level, found, marker, prevPos\n\n  const max = state.posMax\n  const oldPos = state.pos\n\n  state.pos = start + 1\n  level = 1\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos)\n    if (marker === 0x5D /* ] */) {\n      level--\n      if (level === 0) {\n        found = true\n        break\n      }\n    }\n\n    prevPos = state.pos\n    state.md.inline.skipToken(state)\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++\n      } else if (disableNested) {\n        state.pos = oldPos\n        return -1\n      }\n    }\n  }\n\n  let labelEnd = -1\n\n  if (found) {\n    labelEnd = state.pos\n  }\n\n  // restore old state\n  state.pos = oldPos\n\n  return labelEnd\n}\n"]},"metadata":{},"sourceType":"module"}