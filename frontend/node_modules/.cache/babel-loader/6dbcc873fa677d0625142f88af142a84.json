{"ast":null,"code":"// GFM table, https://github.github.com/gfm/#tables-extension-\nimport { isSpace } from '../common/utils.mjs'; // Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\n\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000;\n\nfunction getLine(state, line) {\n  const pos = state.bMarks[line] + state.tShift[line];\n  const max = state.eMarks[line];\n  return state.src.slice(pos, max);\n}\n\nfunction escapedSplit(str) {\n  const result = [];\n  const max = str.length;\n  let pos = 0;\n  let ch = str.charCodeAt(pos);\n  let isEscaped = false;\n  let lastPos = 0;\n  let current = '';\n\n  while (pos < max) {\n    if (ch === 0x7c\n    /* | */\n    ) {\n        if (!isEscaped) {\n          // pipe separating cells, '|'\n          result.push(current + str.substring(lastPos, pos));\n          current = '';\n          lastPos = pos + 1;\n        } else {\n          // escaped pipe, '\\|'\n          current += str.substring(lastPos, pos - 1);\n          lastPos = pos;\n        }\n      }\n\n    isEscaped = ch === 0x5c\n    /* \\ */\n    ;\n    pos++;\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(current + str.substring(lastPos));\n  return result;\n}\n\nexport default function table(state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n\n  let nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  } // if it's indented more than 3 spaces, it should be a code block\n\n\n  if (state.sCount[nextLine] - state.blkIndent >= 4) {\n    return false;\n  } // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n\n  const firstCh = state.src.charCodeAt(pos++);\n\n  if (firstCh !== 0x7C\n  /* | */\n  && firstCh !== 0x2D\n  /* - */\n  && firstCh !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n\n  const secondCh = state.src.charCodeAt(pos++);\n\n  if (secondCh !== 0x7C\n  /* | */\n  && secondCh !== 0x2D\n  /* - */\n  && secondCh !== 0x3A\n  /* : */\n  && !isSpace(secondCh)) {\n    return false;\n  } // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n\n\n  if (firstCh === 0x2D\n  /* - */\n  && isSpace(secondCh)) {\n    return false;\n  }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos);\n\n    if (ch !== 0x7C\n    /* | */\n    && ch !== 0x2D\n    /* - */\n    && ch !== 0x3A\n    /* : */\n    && !isSpace(ch)) {\n      return false;\n    }\n\n    pos++;\n  }\n\n  let lineText = getLine(state, startLine + 1);\n  let columns = lineText.split('|');\n  const aligns = [];\n\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim();\n\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n\n    if (t.charCodeAt(t.length - 1) === 0x3A\n    /* : */\n    ) {\n        aligns.push(t.charCodeAt(0) === 0x3A\n        /* : */\n        ? 'center' : 'right');\n      } else if (t.charCodeAt(0) === 0x3A\n    /* : */\n    ) {\n        aligns.push('left');\n      } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  columns = escapedSplit(lineText);\n  if (columns.length && columns[0] === '') columns.shift();\n  if (columns.length && columns[columns.length - 1] === '') columns.pop(); // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n\n  const columnCount = columns.length;\n\n  if (columnCount === 0 || columnCount !== aligns.length) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  const oldParentType = state.parentType;\n  state.parentType = 'table'; // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n\n  const terminatorRules = state.md.block.ruler.getRules('blockquote');\n  const token_to = state.push('table_open', 'table', 1);\n  const tableLines = [startLine, 0];\n  token_to.map = tableLines;\n  const token_tho = state.push('thead_open', 'thead', 1);\n  token_tho.map = [startLine, startLine + 1];\n  const token_htro = state.push('tr_open', 'tr', 1);\n  token_htro.map = [startLine, startLine + 1];\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1);\n\n    if (aligns[i]) {\n      token_ho.attrs = [['style', 'text-align:' + aligns[i]]];\n    }\n\n    const token_il = state.push('inline', '', 0);\n    token_il.content = columns[i].trim();\n    token_il.children = [];\n    state.push('th_close', 'th', -1);\n  }\n\n  state.push('tr_close', 'tr', -1);\n  state.push('thead_close', 'thead', -1);\n  let tbodyLines;\n  let autocompletedCells = 0;\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    let terminate = false;\n\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n\n    lineText = getLine(state, nextLine).trim();\n\n    if (!lineText) {\n      break;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      break;\n    }\n\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === '') columns.shift();\n    if (columns.length && columns[columns.length - 1] === '') columns.pop(); // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n\n    autocompletedCells += columnCount - columns.length;\n\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {\n      break;\n    }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1);\n      token_tbo.map = tbodyLines = [startLine + 2, 0];\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1);\n    token_tro.map = [nextLine, nextLine + 1];\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1);\n\n      if (aligns[i]) {\n        token_tdo.attrs = [['style', 'text-align:' + aligns[i]]];\n      }\n\n      const token_il = state.push('inline', '', 0);\n      token_il.content = columns[i] ? columns[i].trim() : '';\n      token_il.children = [];\n      state.push('td_close', 'td', -1);\n    }\n\n    state.push('tr_close', 'tr', -1);\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1);\n    tbodyLines[1] = nextLine;\n  }\n\n  state.push('table_close', 'table', -1);\n  tableLines[1] = nextLine;\n  state.parentType = oldParentType;\n  state.line = nextLine;\n  return true;\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_block/table.mjs"],"names":["isSpace","MAX_AUTOCOMPLETED_CELLS","getLine","state","line","pos","bMarks","tShift","max","eMarks","src","slice","escapedSplit","str","result","length","ch","charCodeAt","isEscaped","lastPos","current","push","substring","table","startLine","endLine","silent","nextLine","sCount","blkIndent","firstCh","secondCh","lineText","columns","split","aligns","i","t","trim","test","indexOf","shift","pop","columnCount","oldParentType","parentType","terminatorRules","md","block","ruler","getRules","token_to","tableLines","map","token_tho","token_htro","token_ho","attrs","token_il","content","children","tbodyLines","autocompletedCells","terminate","l","token_tbo","token_tro","token_tdo"],"mappings":"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","sourcesContent":["// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nexport default function table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}