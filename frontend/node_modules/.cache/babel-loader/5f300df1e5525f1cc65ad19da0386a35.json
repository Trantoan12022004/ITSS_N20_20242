{"ast":null,"code":"// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\nimport { arrayReplaceAt } from '../common/utils.mjs';\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\n\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\nexport default function linkify(state) {\n  const blockTokens = state.tokens;\n\n  if (!state.md.options.linkify) {\n    return;\n  }\n\n  for (let j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    let tokens = blockTokens[j].children;\n    let htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const currentToken = tokens[i]; // Skip content of markdown links\n\n      if (currentToken.type === 'link_close') {\n        i--;\n\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n\n        continue;\n      } // Skip content of html tag links\n\n\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        const text = currentToken.content;\n        let links = state.md.linkify.match(text); // Now split string to nodes\n\n        const nodes = [];\n        let level = currentToken.level;\n        let lastPos = 0; // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n\n        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === 'text_special') {\n          links = links.slice(1);\n        }\n\n        for (let ln = 0; ln < links.length; ln++) {\n          const url = links[ln].url;\n          const fullUrl = state.md.normalizeLink(url);\n\n          if (!state.md.validateLink(fullUrl)) {\n            continue;\n          }\n\n          let urlText = links[ln].text; // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          const pos = links[ln].index;\n\n          if (pos > lastPos) {\n            const token = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level = level;\n            nodes.push(token);\n          }\n\n          const token_o = new state.Token('link_open', 'a', 1);\n          token_o.attrs = [['href', fullUrl]];\n          token_o.level = level++;\n          token_o.markup = 'linkify';\n          token_o.info = 'auto';\n          nodes.push(token_o);\n          const token_t = new state.Token('text', '', 0);\n          token_t.content = urlText;\n          token_t.level = level;\n          nodes.push(token_t);\n          const token_c = new state.Token('link_close', 'a', -1);\n          token_c.level = --level;\n          token_c.markup = 'linkify';\n          token_c.info = 'auto';\n          nodes.push(token_c);\n          lastPos = links[ln].lastIndex;\n        }\n\n        if (lastPos < text.length) {\n          const token = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level = level;\n          nodes.push(token);\n        } // replace current node\n\n\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Trant/Documents/Lập Trình Web/5.font-end-react-fullstack/React - Copy/node_modules/markdown-it/lib/rules_core/linkify.mjs"],"names":["arrayReplaceAt","isLinkOpen","str","test","isLinkClose","linkify","state","blockTokens","tokens","md","options","j","l","length","type","pretest","content","children","htmlLinkLevel","i","currentToken","level","text","links","match","nodes","lastPos","index","slice","ln","url","fullUrl","normalizeLink","validateLink","urlText","schema","normalizeLinkText","replace","pos","token","Token","push","token_o","attrs","markup","info","token_t","token_c","lastIndex"],"mappings":"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","sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\nimport { arrayReplaceAt } from '../common/utils.mjs'\n\nfunction isLinkOpen (str) {\n  return /^<a[>\\s]/i.test(str)\n}\nfunction isLinkClose (str) {\n  return /^<\\/a\\s*>/i.test(str)\n}\n\nexport default function linkify (state) {\n  const blockTokens = state.tokens\n\n  if (!state.md.options.linkify) { return }\n\n  for (let j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue\n    }\n\n    let tokens = blockTokens[j].children\n\n    let htmlLinkLevel = 0\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const currentToken = tokens[i]\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--\n        }\n        continue\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++\n        }\n      }\n      if (htmlLinkLevel > 0) { continue }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        const text = currentToken.content\n        let links = state.md.linkify.match(text)\n\n        // Now split string to nodes\n        const nodes = []\n        let level = currentToken.level\n        let lastPos = 0\n\n        // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n        if (links.length > 0 &&\n            links[0].index === 0 &&\n            i > 0 &&\n            tokens[i - 1].type === 'text_special') {\n          links = links.slice(1)\n        }\n\n        for (let ln = 0; ln < links.length; ln++) {\n          const url = links[ln].url\n          const fullUrl = state.md.normalizeLink(url)\n          if (!state.md.validateLink(fullUrl)) { continue }\n\n          let urlText = links[ln].text\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '')\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '')\n          } else {\n            urlText = state.md.normalizeLinkText(urlText)\n          }\n\n          const pos = links[ln].index\n\n          if (pos > lastPos) {\n            const token   = new state.Token('text', '', 0)\n            token.content = text.slice(lastPos, pos)\n            token.level   = level\n            nodes.push(token)\n          }\n\n          const token_o   = new state.Token('link_open', 'a', 1)\n          token_o.attrs   = [['href', fullUrl]]\n          token_o.level   = level++\n          token_o.markup  = 'linkify'\n          token_o.info    = 'auto'\n          nodes.push(token_o)\n\n          const token_t   = new state.Token('text', '', 0)\n          token_t.content = urlText\n          token_t.level   = level\n          nodes.push(token_t)\n\n          const token_c   = new state.Token('link_close', 'a', -1)\n          token_c.level   = --level\n          token_c.markup  = 'linkify'\n          token_c.info    = 'auto'\n          nodes.push(token_c)\n\n          lastPos = links[ln].lastIndex\n        }\n        if (lastPos < text.length) {\n          const token   = new state.Token('text', '', 0)\n          token.content = text.slice(lastPos)\n          token.level   = level\n          nodes.push(token)\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}